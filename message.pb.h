// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_message_2eproto__INCLUDED
#define PROTOBUF_message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace MessageStruct {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_message_2eproto();
void protobuf_AssignDesc_message_2eproto();
void protobuf_ShutdownFile_message_2eproto();

class Echo;
class LogOnorOut;
class ReplyStatus;
class Register;
class ChessBoardUser;
class ChessBoardInfoReq;
class ChessBoardInfo;
class HallInfoReq;
class HallInfo;
class GameHallSumaryReq;
class GameHallSumary;
class RequestPlay;
class RequestPlayReply;
class MoveChess;
class MoveAction;
class UserMessage;
class SystemMessage;
class Reconciled;
class GiveUp;
class Undo;
class GameReadyReq;
class GameStatusReply;
class FindPassword;
class UpdateUserInfo;
class AdPictureItem;
class AdPictureReply;

// ===================================================================

class Echo : public ::google::protobuf::Message {
 public:
  Echo();
  virtual ~Echo();
  
  Echo(const Echo& from);
  
  inline Echo& operator=(const Echo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Echo& default_instance();
  
  void Swap(Echo* other);
  
  // implements Message ----------------------------------------------
  
  Echo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Echo& from);
  void MergeFrom(const Echo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string time_stamp = 1;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 1;
  inline const ::std::string& time_stamp() const;
  inline void set_time_stamp(const ::std::string& value);
  inline void set_time_stamp(const char* value);
  inline void set_time_stamp(const char* value, size_t size);
  inline ::std::string* mutable_time_stamp();
  inline ::std::string* release_time_stamp();
  
  // @@protoc_insertion_point(class_scope:MessageStruct.Echo)
 private:
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* time_stamp_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static Echo* default_instance_;
};
// -------------------------------------------------------------------

class LogOnorOut : public ::google::protobuf::Message {
 public:
  LogOnorOut();
  virtual ~LogOnorOut();
  
  LogOnorOut(const LogOnorOut& from);
  
  inline LogOnorOut& operator=(const LogOnorOut& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogOnorOut& default_instance();
  
  void Swap(LogOnorOut* other);
  
  // implements Message ----------------------------------------------
  
  LogOnorOut* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogOnorOut& from);
  void MergeFrom(const LogOnorOut& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  
  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // @@protoc_insertion_point(class_scope:MessageStruct.LogOnorOut)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_password();
  inline void clear_has_password();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* account_;
  ::std::string* password_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static LogOnorOut* default_instance_;
};
// -------------------------------------------------------------------

class ReplyStatus : public ::google::protobuf::Message {
 public:
  ReplyStatus();
  virtual ~ReplyStatus();
  
  ReplyStatus(const ReplyStatus& from);
  
  inline ReplyStatus& operator=(const ReplyStatus& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReplyStatus& default_instance();
  
  void Swap(ReplyStatus* other);
  
  // implements Message ----------------------------------------------
  
  ReplyStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReplyStatus& from);
  void MergeFrom(const ReplyStatus& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);
  
  // optional .MessageStruct.ChessBoardUser user = 2;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 2;
  inline const ::MessageStruct::ChessBoardUser& user() const;
  inline ::MessageStruct::ChessBoardUser* mutable_user();
  inline ::MessageStruct::ChessBoardUser* release_user();
  
  // @@protoc_insertion_point(class_scope:MessageStruct.ReplyStatus)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_user();
  inline void clear_has_user();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::MessageStruct::ChessBoardUser* user_;
  ::google::protobuf::uint32 status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static ReplyStatus* default_instance_;
};
// -------------------------------------------------------------------

class Register : public ::google::protobuf::Message {
 public:
  Register();
  virtual ~Register();
  
  Register(const Register& from);
  
  inline Register& operator=(const Register& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Register& default_instance();
  
  void Swap(Register* other);
  
  // implements Message ----------------------------------------------
  
  Register* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Register& from);
  void MergeFrom(const Register& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string email_account = 1;
  inline bool has_email_account() const;
  inline void clear_email_account();
  static const int kEmailAccountFieldNumber = 1;
  inline const ::std::string& email_account() const;
  inline void set_email_account(const ::std::string& value);
  inline void set_email_account(const char* value);
  inline void set_email_account(const char* value, size_t size);
  inline ::std::string* mutable_email_account();
  inline ::std::string* release_email_account();
  
  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // optional string username = 3;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 3;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // @@protoc_insertion_point(class_scope:MessageStruct.Register)
 private:
  inline void set_has_email_account();
  inline void clear_has_email_account();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_username();
  inline void clear_has_username();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* email_account_;
  ::std::string* password_;
  ::std::string* username_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static Register* default_instance_;
};
// -------------------------------------------------------------------

class ChessBoardUser : public ::google::protobuf::Message {
 public:
  ChessBoardUser();
  virtual ~ChessBoardUser();
  
  ChessBoardUser(const ChessBoardUser& from);
  
  inline ChessBoardUser& operator=(const ChessBoardUser& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChessBoardUser& default_instance();
  
  void Swap(ChessBoardUser* other);
  
  // implements Message ----------------------------------------------
  
  ChessBoardUser* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChessBoardUser& from);
  void MergeFrom(const ChessBoardUser& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool chess_board_empty = 1;
  inline bool has_chess_board_empty() const;
  inline void clear_chess_board_empty();
  static const int kChessBoardEmptyFieldNumber = 1;
  inline bool chess_board_empty() const;
  inline void set_chess_board_empty(bool value);
  
  // optional string user_name = 2;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 2;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  
  // optional string account = 3;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 3;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  
  // optional int32 score = 4;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 4;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);
  
  // optional string ex_email = 5;
  inline bool has_ex_email() const;
  inline void clear_ex_email();
  static const int kExEmailFieldNumber = 5;
  inline const ::std::string& ex_email() const;
  inline void set_ex_email(const ::std::string& value);
  inline void set_ex_email(const char* value);
  inline void set_ex_email(const char* value, size_t size);
  inline ::std::string* mutable_ex_email();
  inline ::std::string* release_ex_email();
  
  // optional string phone = 6;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 6;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  
  // optional bytes head_image = 7;
  inline bool has_head_image() const;
  inline void clear_head_image();
  static const int kHeadImageFieldNumber = 7;
  inline const ::std::string& head_image() const;
  inline void set_head_image(const ::std::string& value);
  inline void set_head_image(const char* value);
  inline void set_head_image(const void* value, size_t size);
  inline ::std::string* mutable_head_image();
  inline ::std::string* release_head_image();
  
  // optional uint32 status = 8;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 8;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:MessageStruct.ChessBoardUser)
 private:
  inline void set_has_chess_board_empty();
  inline void clear_has_chess_board_empty();
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_ex_email();
  inline void clear_has_ex_email();
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_head_image();
  inline void clear_has_head_image();
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* user_name_;
  bool chess_board_empty_;
  ::google::protobuf::int32 score_;
  ::std::string* account_;
  ::std::string* ex_email_;
  ::std::string* phone_;
  ::std::string* head_image_;
  ::google::protobuf::uint32 status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static ChessBoardUser* default_instance_;
};
// -------------------------------------------------------------------

class ChessBoardInfoReq : public ::google::protobuf::Message {
 public:
  ChessBoardInfoReq();
  virtual ~ChessBoardInfoReq();
  
  ChessBoardInfoReq(const ChessBoardInfoReq& from);
  
  inline ChessBoardInfoReq& operator=(const ChessBoardInfoReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChessBoardInfoReq& default_instance();
  
  void Swap(ChessBoardInfoReq* other);
  
  // implements Message ----------------------------------------------
  
  ChessBoardInfoReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChessBoardInfoReq& from);
  void MergeFrom(const ChessBoardInfoReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 chess_board_id = 1;
  inline bool has_chess_board_id() const;
  inline void clear_chess_board_id();
  static const int kChessBoardIdFieldNumber = 1;
  inline ::google::protobuf::int32 chess_board_id() const;
  inline void set_chess_board_id(::google::protobuf::int32 value);
  
  // optional int32 opcode = 2;
  inline bool has_opcode() const;
  inline void clear_opcode();
  static const int kOpcodeFieldNumber = 2;
  inline ::google::protobuf::int32 opcode() const;
  inline void set_opcode(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:MessageStruct.ChessBoardInfoReq)
 private:
  inline void set_has_chess_board_id();
  inline void clear_has_chess_board_id();
  inline void set_has_opcode();
  inline void clear_has_opcode();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 chess_board_id_;
  ::google::protobuf::int32 opcode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static ChessBoardInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class ChessBoardInfo : public ::google::protobuf::Message {
 public:
  ChessBoardInfo();
  virtual ~ChessBoardInfo();
  
  ChessBoardInfo(const ChessBoardInfo& from);
  
  inline ChessBoardInfo& operator=(const ChessBoardInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChessBoardInfo& default_instance();
  
  void Swap(ChessBoardInfo* other);
  
  // implements Message ----------------------------------------------
  
  ChessBoardInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChessBoardInfo& from);
  void MergeFrom(const ChessBoardInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // required uint32 people_num = 2;
  inline bool has_people_num() const;
  inline void clear_people_num();
  static const int kPeopleNumFieldNumber = 2;
  inline ::google::protobuf::uint32 people_num() const;
  inline void set_people_num(::google::protobuf::uint32 value);
  
  // required .MessageStruct.ChessBoardUser left_user = 3;
  inline bool has_left_user() const;
  inline void clear_left_user();
  static const int kLeftUserFieldNumber = 3;
  inline const ::MessageStruct::ChessBoardUser& left_user() const;
  inline ::MessageStruct::ChessBoardUser* mutable_left_user();
  inline ::MessageStruct::ChessBoardUser* release_left_user();
  
  // required .MessageStruct.ChessBoardUser right_user = 4;
  inline bool has_right_user() const;
  inline void clear_right_user();
  static const int kRightUserFieldNumber = 4;
  inline const ::MessageStruct::ChessBoardUser& right_user() const;
  inline ::MessageStruct::ChessBoardUser* mutable_right_user();
  inline ::MessageStruct::ChessBoardUser* release_right_user();
  
  // required .MessageStruct.ChessBoardUser bottom_user = 5;
  inline bool has_bottom_user() const;
  inline void clear_bottom_user();
  static const int kBottomUserFieldNumber = 5;
  inline const ::MessageStruct::ChessBoardUser& bottom_user() const;
  inline ::MessageStruct::ChessBoardUser* mutable_bottom_user();
  inline ::MessageStruct::ChessBoardUser* release_bottom_user();
  
  // @@protoc_insertion_point(class_scope:MessageStruct.ChessBoardInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_people_num();
  inline void clear_has_people_num();
  inline void set_has_left_user();
  inline void clear_has_left_user();
  inline void set_has_right_user();
  inline void clear_has_right_user();
  inline void set_has_bottom_user();
  inline void clear_has_bottom_user();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 people_num_;
  ::MessageStruct::ChessBoardUser* left_user_;
  ::MessageStruct::ChessBoardUser* right_user_;
  ::MessageStruct::ChessBoardUser* bottom_user_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static ChessBoardInfo* default_instance_;
};
// -------------------------------------------------------------------

class HallInfoReq : public ::google::protobuf::Message {
 public:
  HallInfoReq();
  virtual ~HallInfoReq();
  
  HallInfoReq(const HallInfoReq& from);
  
  inline HallInfoReq& operator=(const HallInfoReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HallInfoReq& default_instance();
  
  void Swap(HallInfoReq* other);
  
  // implements Message ----------------------------------------------
  
  HallInfoReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HallInfoReq& from);
  void MergeFrom(const HallInfoReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 game_hall_id = 1;
  inline bool has_game_hall_id() const;
  inline void clear_game_hall_id();
  static const int kGameHallIdFieldNumber = 1;
  inline ::google::protobuf::int32 game_hall_id() const;
  inline void set_game_hall_id(::google::protobuf::int32 value);
  
  // optional int32 opcode = 2;
  inline bool has_opcode() const;
  inline void clear_opcode();
  static const int kOpcodeFieldNumber = 2;
  inline ::google::protobuf::int32 opcode() const;
  inline void set_opcode(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:MessageStruct.HallInfoReq)
 private:
  inline void set_has_game_hall_id();
  inline void clear_has_game_hall_id();
  inline void set_has_opcode();
  inline void clear_has_opcode();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 game_hall_id_;
  ::google::protobuf::int32 opcode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static HallInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class HallInfo : public ::google::protobuf::Message {
 public:
  HallInfo();
  virtual ~HallInfo();
  
  HallInfo(const HallInfo& from);
  
  inline HallInfo& operator=(const HallInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HallInfo& default_instance();
  
  void Swap(HallInfo* other);
  
  // implements Message ----------------------------------------------
  
  HallInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HallInfo& from);
  void MergeFrom(const HallInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 game_hall_id = 1;
  inline bool has_game_hall_id() const;
  inline void clear_game_hall_id();
  static const int kGameHallIdFieldNumber = 1;
  inline ::google::protobuf::int32 game_hall_id() const;
  inline void set_game_hall_id(::google::protobuf::int32 value);
  
  // required uint32 total_people = 2;
  inline bool has_total_people() const;
  inline void clear_total_people();
  static const int kTotalPeopleFieldNumber = 2;
  inline ::google::protobuf::uint32 total_people() const;
  inline void set_total_people(::google::protobuf::uint32 value);
  
  // required uint32 curr_people = 3;
  inline bool has_curr_people() const;
  inline void clear_curr_people();
  static const int kCurrPeopleFieldNumber = 3;
  inline ::google::protobuf::uint32 curr_people() const;
  inline void set_curr_people(::google::protobuf::uint32 value);
  
  // optional uint32 total_chessboard = 4;
  inline bool has_total_chessboard() const;
  inline void clear_total_chessboard();
  static const int kTotalChessboardFieldNumber = 4;
  inline ::google::protobuf::uint32 total_chessboard() const;
  inline void set_total_chessboard(::google::protobuf::uint32 value);
  
  // repeated .MessageStruct.ChessBoardInfo chess_board = 5;
  inline int chess_board_size() const;
  inline void clear_chess_board();
  static const int kChessBoardFieldNumber = 5;
  inline const ::MessageStruct::ChessBoardInfo& chess_board(int index) const;
  inline ::MessageStruct::ChessBoardInfo* mutable_chess_board(int index);
  inline ::MessageStruct::ChessBoardInfo* add_chess_board();
  inline const ::google::protobuf::RepeatedPtrField< ::MessageStruct::ChessBoardInfo >&
      chess_board() const;
  inline ::google::protobuf::RepeatedPtrField< ::MessageStruct::ChessBoardInfo >*
      mutable_chess_board();
  
  // @@protoc_insertion_point(class_scope:MessageStruct.HallInfo)
 private:
  inline void set_has_game_hall_id();
  inline void clear_has_game_hall_id();
  inline void set_has_total_people();
  inline void clear_has_total_people();
  inline void set_has_curr_people();
  inline void clear_has_curr_people();
  inline void set_has_total_chessboard();
  inline void clear_has_total_chessboard();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 game_hall_id_;
  ::google::protobuf::uint32 total_people_;
  ::google::protobuf::uint32 curr_people_;
  ::google::protobuf::uint32 total_chessboard_;
  ::google::protobuf::RepeatedPtrField< ::MessageStruct::ChessBoardInfo > chess_board_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static HallInfo* default_instance_;
};
// -------------------------------------------------------------------

class GameHallSumaryReq : public ::google::protobuf::Message {
 public:
  GameHallSumaryReq();
  virtual ~GameHallSumaryReq();
  
  GameHallSumaryReq(const GameHallSumaryReq& from);
  
  inline GameHallSumaryReq& operator=(const GameHallSumaryReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameHallSumaryReq& default_instance();
  
  void Swap(GameHallSumaryReq* other);
  
  // implements Message ----------------------------------------------
  
  GameHallSumaryReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameHallSumaryReq& from);
  void MergeFrom(const GameHallSumaryReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 opcode = 1;
  inline bool has_opcode() const;
  inline void clear_opcode();
  static const int kOpcodeFieldNumber = 1;
  inline ::google::protobuf::int32 opcode() const;
  inline void set_opcode(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:MessageStruct.GameHallSumaryReq)
 private:
  inline void set_has_opcode();
  inline void clear_has_opcode();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 opcode_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static GameHallSumaryReq* default_instance_;
};
// -------------------------------------------------------------------

class GameHallSumary : public ::google::protobuf::Message {
 public:
  GameHallSumary();
  virtual ~GameHallSumary();
  
  GameHallSumary(const GameHallSumary& from);
  
  inline GameHallSumary& operator=(const GameHallSumary& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameHallSumary& default_instance();
  
  void Swap(GameHallSumary* other);
  
  // implements Message ----------------------------------------------
  
  GameHallSumary* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameHallSumary& from);
  void MergeFrom(const GameHallSumary& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  
  // required string username = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  
  // required int32 score = 3;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 3;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);
  
  // required uint32 hall_num = 4;
  inline bool has_hall_num() const;
  inline void clear_hall_num();
  static const int kHallNumFieldNumber = 4;
  inline ::google::protobuf::uint32 hall_num() const;
  inline void set_hall_num(::google::protobuf::uint32 value);
  
  // required string head_picture = 5;
  inline bool has_head_picture() const;
  inline void clear_head_picture();
  static const int kHeadPictureFieldNumber = 5;
  inline const ::std::string& head_picture() const;
  inline void set_head_picture(const ::std::string& value);
  inline void set_head_picture(const char* value);
  inline void set_head_picture(const char* value, size_t size);
  inline ::std::string* mutable_head_picture();
  inline ::std::string* release_head_picture();
  
  // required string ad_picture1 = 6;
  inline bool has_ad_picture1() const;
  inline void clear_ad_picture1();
  static const int kAdPicture1FieldNumber = 6;
  inline const ::std::string& ad_picture1() const;
  inline void set_ad_picture1(const ::std::string& value);
  inline void set_ad_picture1(const char* value);
  inline void set_ad_picture1(const char* value, size_t size);
  inline ::std::string* mutable_ad_picture1();
  inline ::std::string* release_ad_picture1();
  
  // optional string ad_picture2 = 7;
  inline bool has_ad_picture2() const;
  inline void clear_ad_picture2();
  static const int kAdPicture2FieldNumber = 7;
  inline const ::std::string& ad_picture2() const;
  inline void set_ad_picture2(const ::std::string& value);
  inline void set_ad_picture2(const char* value);
  inline void set_ad_picture2(const char* value, size_t size);
  inline ::std::string* mutable_ad_picture2();
  inline ::std::string* release_ad_picture2();
  
  // repeated .MessageStruct.HallInfo hall_info = 8;
  inline int hall_info_size() const;
  inline void clear_hall_info();
  static const int kHallInfoFieldNumber = 8;
  inline const ::MessageStruct::HallInfo& hall_info(int index) const;
  inline ::MessageStruct::HallInfo* mutable_hall_info(int index);
  inline ::MessageStruct::HallInfo* add_hall_info();
  inline const ::google::protobuf::RepeatedPtrField< ::MessageStruct::HallInfo >&
      hall_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::MessageStruct::HallInfo >*
      mutable_hall_info();
  
  // @@protoc_insertion_point(class_scope:MessageStruct.GameHallSumary)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_hall_num();
  inline void clear_has_hall_num();
  inline void set_has_head_picture();
  inline void clear_has_head_picture();
  inline void set_has_ad_picture1();
  inline void clear_has_ad_picture1();
  inline void set_has_ad_picture2();
  inline void clear_has_ad_picture2();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* account_;
  ::std::string* username_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::uint32 hall_num_;
  ::std::string* head_picture_;
  ::std::string* ad_picture1_;
  ::std::string* ad_picture2_;
  ::google::protobuf::RepeatedPtrField< ::MessageStruct::HallInfo > hall_info_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static GameHallSumary* default_instance_;
};
// -------------------------------------------------------------------

class RequestPlay : public ::google::protobuf::Message {
 public:
  RequestPlay();
  virtual ~RequestPlay();
  
  RequestPlay(const RequestPlay& from);
  
  inline RequestPlay& operator=(const RequestPlay& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestPlay& default_instance();
  
  void Swap(RequestPlay* other);
  
  // implements Message ----------------------------------------------
  
  RequestPlay* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestPlay& from);
  void MergeFrom(const RequestPlay& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 game_hall_id = 1;
  inline bool has_game_hall_id() const;
  inline void clear_game_hall_id();
  static const int kGameHallIdFieldNumber = 1;
  inline ::google::protobuf::int32 game_hall_id() const;
  inline void set_game_hall_id(::google::protobuf::int32 value);
  
  // required int32 chess_board_id = 2;
  inline bool has_chess_board_id() const;
  inline void clear_chess_board_id();
  static const int kChessBoardIdFieldNumber = 2;
  inline ::google::protobuf::int32 chess_board_id() const;
  inline void set_chess_board_id(::google::protobuf::int32 value);
  
  // required int32 locate = 3;
  inline bool has_locate() const;
  inline void clear_locate();
  static const int kLocateFieldNumber = 3;
  inline ::google::protobuf::int32 locate() const;
  inline void set_locate(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:MessageStruct.RequestPlay)
 private:
  inline void set_has_game_hall_id();
  inline void clear_has_game_hall_id();
  inline void set_has_chess_board_id();
  inline void clear_has_chess_board_id();
  inline void set_has_locate();
  inline void clear_has_locate();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 game_hall_id_;
  ::google::protobuf::int32 chess_board_id_;
  ::google::protobuf::int32 locate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static RequestPlay* default_instance_;
};
// -------------------------------------------------------------------

class RequestPlayReply : public ::google::protobuf::Message {
 public:
  RequestPlayReply();
  virtual ~RequestPlayReply();
  
  RequestPlayReply(const RequestPlayReply& from);
  
  inline RequestPlayReply& operator=(const RequestPlayReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestPlayReply& default_instance();
  
  void Swap(RequestPlayReply* other);
  
  // implements Message ----------------------------------------------
  
  RequestPlayReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequestPlayReply& from);
  void MergeFrom(const RequestPlayReply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);
  
  // required uint32 first_come_user_locate = 2;
  inline bool has_first_come_user_locate() const;
  inline void clear_first_come_user_locate();
  static const int kFirstComeUserLocateFieldNumber = 2;
  inline ::google::protobuf::uint32 first_come_user_locate() const;
  inline void set_first_come_user_locate(::google::protobuf::uint32 value);
  
  // optional .MessageStruct.ChessBoardInfo chessBoard = 3;
  inline bool has_chessboard() const;
  inline void clear_chessboard();
  static const int kChessBoardFieldNumber = 3;
  inline const ::MessageStruct::ChessBoardInfo& chessboard() const;
  inline ::MessageStruct::ChessBoardInfo* mutable_chessboard();
  inline ::MessageStruct::ChessBoardInfo* release_chessboard();
  
  // @@protoc_insertion_point(class_scope:MessageStruct.RequestPlayReply)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_first_come_user_locate();
  inline void clear_has_first_come_user_locate();
  inline void set_has_chessboard();
  inline void clear_has_chessboard();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 status_;
  ::google::protobuf::uint32 first_come_user_locate_;
  ::MessageStruct::ChessBoardInfo* chessboard_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static RequestPlayReply* default_instance_;
};
// -------------------------------------------------------------------

class MoveChess : public ::google::protobuf::Message {
 public:
  MoveChess();
  virtual ~MoveChess();
  
  MoveChess(const MoveChess& from);
  
  inline MoveChess& operator=(const MoveChess& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MoveChess& default_instance();
  
  void Swap(MoveChess* other);
  
  // implements Message ----------------------------------------------
  
  MoveChess* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoveChess& from);
  void MergeFrom(const MoveChess& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 src_chess_type = 1;
  inline bool has_src_chess_type() const;
  inline void clear_src_chess_type();
  static const int kSrcChessTypeFieldNumber = 1;
  inline ::google::protobuf::int32 src_chess_type() const;
  inline void set_src_chess_type(::google::protobuf::int32 value);
  
  // required int32 src_user_locate = 2;
  inline bool has_src_user_locate() const;
  inline void clear_src_user_locate();
  static const int kSrcUserLocateFieldNumber = 2;
  inline ::google::protobuf::int32 src_user_locate() const;
  inline void set_src_user_locate(::google::protobuf::int32 value);
  
  // required int32 from_pointX = 3;
  inline bool has_from_pointx() const;
  inline void clear_from_pointx();
  static const int kFromPointXFieldNumber = 3;
  inline ::google::protobuf::int32 from_pointx() const;
  inline void set_from_pointx(::google::protobuf::int32 value);
  
  // required int32 from_pointY = 4;
  inline bool has_from_pointy() const;
  inline void clear_from_pointy();
  static const int kFromPointYFieldNumber = 4;
  inline ::google::protobuf::int32 from_pointy() const;
  inline void set_from_pointy(::google::protobuf::int32 value);
  
  // required int32 des_pointX = 5;
  inline bool has_des_pointx() const;
  inline void clear_des_pointx();
  static const int kDesPointXFieldNumber = 5;
  inline ::google::protobuf::int32 des_pointx() const;
  inline void set_des_pointx(::google::protobuf::int32 value);
  
  // required int32 des_pointY = 6;
  inline bool has_des_pointy() const;
  inline void clear_des_pointy();
  static const int kDesPointYFieldNumber = 6;
  inline ::google::protobuf::int32 des_pointy() const;
  inline void set_des_pointy(::google::protobuf::int32 value);
  
  // required bool is_winner = 7;
  inline bool has_is_winner() const;
  inline void clear_is_winner();
  static const int kIsWinnerFieldNumber = 7;
  inline bool is_winner() const;
  inline void set_is_winner(bool value);
  
  // optional int32 eat_target_chess_type = 8;
  inline bool has_eat_target_chess_type() const;
  inline void clear_eat_target_chess_type();
  static const int kEatTargetChessTypeFieldNumber = 8;
  inline ::google::protobuf::int32 eat_target_chess_type() const;
  inline void set_eat_target_chess_type(::google::protobuf::int32 value);
  
  // optional uint32 target_user_locate = 9;
  inline bool has_target_user_locate() const;
  inline void clear_target_user_locate();
  static const int kTargetUserLocateFieldNumber = 9;
  inline ::google::protobuf::uint32 target_user_locate() const;
  inline void set_target_user_locate(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:MessageStruct.MoveChess)
 private:
  inline void set_has_src_chess_type();
  inline void clear_has_src_chess_type();
  inline void set_has_src_user_locate();
  inline void clear_has_src_user_locate();
  inline void set_has_from_pointx();
  inline void clear_has_from_pointx();
  inline void set_has_from_pointy();
  inline void clear_has_from_pointy();
  inline void set_has_des_pointx();
  inline void clear_has_des_pointx();
  inline void set_has_des_pointy();
  inline void clear_has_des_pointy();
  inline void set_has_is_winner();
  inline void clear_has_is_winner();
  inline void set_has_eat_target_chess_type();
  inline void clear_has_eat_target_chess_type();
  inline void set_has_target_user_locate();
  inline void clear_has_target_user_locate();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 src_chess_type_;
  ::google::protobuf::int32 src_user_locate_;
  ::google::protobuf::int32 from_pointx_;
  ::google::protobuf::int32 from_pointy_;
  ::google::protobuf::int32 des_pointx_;
  ::google::protobuf::int32 des_pointy_;
  bool is_winner_;
  ::google::protobuf::int32 eat_target_chess_type_;
  ::google::protobuf::uint32 target_user_locate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static MoveChess* default_instance_;
};
// -------------------------------------------------------------------

class MoveAction : public ::google::protobuf::Message {
 public:
  MoveAction();
  virtual ~MoveAction();
  
  MoveAction(const MoveAction& from);
  
  inline MoveAction& operator=(const MoveAction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MoveAction& default_instance();
  
  void Swap(MoveAction* other);
  
  // implements Message ----------------------------------------------
  
  MoveAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MoveAction& from);
  void MergeFrom(const MoveAction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 src_user_locate = 1;
  inline bool has_src_user_locate() const;
  inline void clear_src_user_locate();
  static const int kSrcUserLocateFieldNumber = 1;
  inline ::google::protobuf::uint32 src_user_locate() const;
  inline void set_src_user_locate(::google::protobuf::uint32 value);
  
  // required .MessageStruct.MoveChess movechess = 2;
  inline bool has_movechess() const;
  inline void clear_movechess();
  static const int kMovechessFieldNumber = 2;
  inline const ::MessageStruct::MoveChess& movechess() const;
  inline ::MessageStruct::MoveChess* mutable_movechess();
  inline ::MessageStruct::MoveChess* release_movechess();
  
  // required uint32 token_locate = 3;
  inline bool has_token_locate() const;
  inline void clear_token_locate();
  static const int kTokenLocateFieldNumber = 3;
  inline ::google::protobuf::uint32 token_locate() const;
  inline void set_token_locate(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:MessageStruct.MoveAction)
 private:
  inline void set_has_src_user_locate();
  inline void clear_has_src_user_locate();
  inline void set_has_movechess();
  inline void clear_has_movechess();
  inline void set_has_token_locate();
  inline void clear_has_token_locate();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::MessageStruct::MoveChess* movechess_;
  ::google::protobuf::uint32 src_user_locate_;
  ::google::protobuf::uint32 token_locate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static MoveAction* default_instance_;
};
// -------------------------------------------------------------------

class UserMessage : public ::google::protobuf::Message {
 public:
  UserMessage();
  virtual ~UserMessage();
  
  UserMessage(const UserMessage& from);
  
  inline UserMessage& operator=(const UserMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserMessage& default_instance();
  
  void Swap(UserMessage* other);
  
  // implements Message ----------------------------------------------
  
  UserMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserMessage& from);
  void MergeFrom(const UserMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 src_user_locate = 1;
  inline bool has_src_user_locate() const;
  inline void clear_src_user_locate();
  static const int kSrcUserLocateFieldNumber = 1;
  inline ::google::protobuf::uint32 src_user_locate() const;
  inline void set_src_user_locate(::google::protobuf::uint32 value);
  
  // required string msgContent = 2;
  inline bool has_msgcontent() const;
  inline void clear_msgcontent();
  static const int kMsgContentFieldNumber = 2;
  inline const ::std::string& msgcontent() const;
  inline void set_msgcontent(const ::std::string& value);
  inline void set_msgcontent(const char* value);
  inline void set_msgcontent(const char* value, size_t size);
  inline ::std::string* mutable_msgcontent();
  inline ::std::string* release_msgcontent();
  
  // @@protoc_insertion_point(class_scope:MessageStruct.UserMessage)
 private:
  inline void set_has_src_user_locate();
  inline void clear_has_src_user_locate();
  inline void set_has_msgcontent();
  inline void clear_has_msgcontent();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* msgcontent_;
  ::google::protobuf::uint32 src_user_locate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static UserMessage* default_instance_;
};
// -------------------------------------------------------------------

class SystemMessage : public ::google::protobuf::Message {
 public:
  SystemMessage();
  virtual ~SystemMessage();
  
  SystemMessage(const SystemMessage& from);
  
  inline SystemMessage& operator=(const SystemMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemMessage& default_instance();
  
  void Swap(SystemMessage* other);
  
  // implements Message ----------------------------------------------
  
  SystemMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SystemMessage& from);
  void MergeFrom(const SystemMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string msgContent = 1;
  inline bool has_msgcontent() const;
  inline void clear_msgcontent();
  static const int kMsgContentFieldNumber = 1;
  inline const ::std::string& msgcontent() const;
  inline void set_msgcontent(const ::std::string& value);
  inline void set_msgcontent(const char* value);
  inline void set_msgcontent(const char* value, size_t size);
  inline ::std::string* mutable_msgcontent();
  inline ::std::string* release_msgcontent();
  
  // @@protoc_insertion_point(class_scope:MessageStruct.SystemMessage)
 private:
  inline void set_has_msgcontent();
  inline void clear_has_msgcontent();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* msgcontent_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static SystemMessage* default_instance_;
};
// -------------------------------------------------------------------

class Reconciled : public ::google::protobuf::Message {
 public:
  Reconciled();
  virtual ~Reconciled();
  
  Reconciled(const Reconciled& from);
  
  inline Reconciled& operator=(const Reconciled& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Reconciled& default_instance();
  
  void Swap(Reconciled* other);
  
  // implements Message ----------------------------------------------
  
  Reconciled* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Reconciled& from);
  void MergeFrom(const Reconciled& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 apply_or_reply = 1;
  inline bool has_apply_or_reply() const;
  inline void clear_apply_or_reply();
  static const int kApplyOrReplyFieldNumber = 1;
  inline ::google::protobuf::uint32 apply_or_reply() const;
  inline void set_apply_or_reply(::google::protobuf::uint32 value);
  
  // required uint32 src_user_locate = 2;
  inline bool has_src_user_locate() const;
  inline void clear_src_user_locate();
  static const int kSrcUserLocateFieldNumber = 2;
  inline ::google::protobuf::uint32 src_user_locate() const;
  inline void set_src_user_locate(::google::protobuf::uint32 value);
  
  // required uint32 tar_user_locate = 3;
  inline bool has_tar_user_locate() const;
  inline void clear_tar_user_locate();
  static const int kTarUserLocateFieldNumber = 3;
  inline ::google::protobuf::uint32 tar_user_locate() const;
  inline void set_tar_user_locate(::google::protobuf::uint32 value);
  
  // optional string status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline const ::std::string& status() const;
  inline void set_status(const ::std::string& value);
  inline void set_status(const char* value);
  inline void set_status(const char* value, size_t size);
  inline ::std::string* mutable_status();
  inline ::std::string* release_status();
  
  // @@protoc_insertion_point(class_scope:MessageStruct.Reconciled)
 private:
  inline void set_has_apply_or_reply();
  inline void clear_has_apply_or_reply();
  inline void set_has_src_user_locate();
  inline void clear_has_src_user_locate();
  inline void set_has_tar_user_locate();
  inline void clear_has_tar_user_locate();
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 apply_or_reply_;
  ::google::protobuf::uint32 src_user_locate_;
  ::std::string* status_;
  ::google::protobuf::uint32 tar_user_locate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static Reconciled* default_instance_;
};
// -------------------------------------------------------------------

class GiveUp : public ::google::protobuf::Message {
 public:
  GiveUp();
  virtual ~GiveUp();
  
  GiveUp(const GiveUp& from);
  
  inline GiveUp& operator=(const GiveUp& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GiveUp& default_instance();
  
  void Swap(GiveUp* other);
  
  // implements Message ----------------------------------------------
  
  GiveUp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GiveUp& from);
  void MergeFrom(const GiveUp& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 src_user_locate = 1;
  inline bool has_src_user_locate() const;
  inline void clear_src_user_locate();
  static const int kSrcUserLocateFieldNumber = 1;
  inline ::google::protobuf::uint32 src_user_locate() const;
  inline void set_src_user_locate(::google::protobuf::uint32 value);
  
  // optional string opt = 2;
  inline bool has_opt() const;
  inline void clear_opt();
  static const int kOptFieldNumber = 2;
  inline const ::std::string& opt() const;
  inline void set_opt(const ::std::string& value);
  inline void set_opt(const char* value);
  inline void set_opt(const char* value, size_t size);
  inline ::std::string* mutable_opt();
  inline ::std::string* release_opt();
  
  // @@protoc_insertion_point(class_scope:MessageStruct.GiveUp)
 private:
  inline void set_has_src_user_locate();
  inline void clear_has_src_user_locate();
  inline void set_has_opt();
  inline void clear_has_opt();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* opt_;
  ::google::protobuf::uint32 src_user_locate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static GiveUp* default_instance_;
};
// -------------------------------------------------------------------

class Undo : public ::google::protobuf::Message {
 public:
  Undo();
  virtual ~Undo();
  
  Undo(const Undo& from);
  
  inline Undo& operator=(const Undo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Undo& default_instance();
  
  void Swap(Undo* other);
  
  // implements Message ----------------------------------------------
  
  Undo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Undo& from);
  void MergeFrom(const Undo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 rep_or_respon = 1;
  inline bool has_rep_or_respon() const;
  inline void clear_rep_or_respon();
  static const int kRepOrResponFieldNumber = 1;
  inline ::google::protobuf::uint32 rep_or_respon() const;
  inline void set_rep_or_respon(::google::protobuf::uint32 value);
  
  // required uint32 src_user_locate = 2;
  inline bool has_src_user_locate() const;
  inline void clear_src_user_locate();
  static const int kSrcUserLocateFieldNumber = 2;
  inline ::google::protobuf::uint32 src_user_locate() const;
  inline void set_src_user_locate(::google::protobuf::uint32 value);
  
  // required uint32 tar_user_locate = 3;
  inline bool has_tar_user_locate() const;
  inline void clear_tar_user_locate();
  static const int kTarUserLocateFieldNumber = 3;
  inline ::google::protobuf::uint32 tar_user_locate() const;
  inline void set_tar_user_locate(::google::protobuf::uint32 value);
  
  // optional bool status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline bool status() const;
  inline void set_status(bool value);
  
  // @@protoc_insertion_point(class_scope:MessageStruct.Undo)
 private:
  inline void set_has_rep_or_respon();
  inline void clear_has_rep_or_respon();
  inline void set_has_src_user_locate();
  inline void clear_has_src_user_locate();
  inline void set_has_tar_user_locate();
  inline void clear_has_tar_user_locate();
  inline void set_has_status();
  inline void clear_has_status();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 rep_or_respon_;
  ::google::protobuf::uint32 src_user_locate_;
  ::google::protobuf::uint32 tar_user_locate_;
  bool status_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static Undo* default_instance_;
};
// -------------------------------------------------------------------

class GameReadyReq : public ::google::protobuf::Message {
 public:
  GameReadyReq();
  virtual ~GameReadyReq();
  
  GameReadyReq(const GameReadyReq& from);
  
  inline GameReadyReq& operator=(const GameReadyReq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameReadyReq& default_instance();
  
  void Swap(GameReadyReq* other);
  
  // implements Message ----------------------------------------------
  
  GameReadyReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameReadyReq& from);
  void MergeFrom(const GameReadyReq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 src_user_locate = 1;
  inline bool has_src_user_locate() const;
  inline void clear_src_user_locate();
  static const int kSrcUserLocateFieldNumber = 1;
  inline ::google::protobuf::uint32 src_user_locate() const;
  inline void set_src_user_locate(::google::protobuf::uint32 value);
  
  // optional uint32 opcode = 2;
  inline bool has_opcode() const;
  inline void clear_opcode();
  static const int kOpcodeFieldNumber = 2;
  inline ::google::protobuf::uint32 opcode() const;
  inline void set_opcode(::google::protobuf::uint32 value);
  
  // optional uint32 total_time = 3;
  inline bool has_total_time() const;
  inline void clear_total_time();
  static const int kTotalTimeFieldNumber = 3;
  inline ::google::protobuf::uint32 total_time() const;
  inline void set_total_time(::google::protobuf::uint32 value);
  
  // optional uint32 single_step_time = 4;
  inline bool has_single_step_time() const;
  inline void clear_single_step_time();
  static const int kSingleStepTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 single_step_time() const;
  inline void set_single_step_time(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:MessageStruct.GameReadyReq)
 private:
  inline void set_has_src_user_locate();
  inline void clear_has_src_user_locate();
  inline void set_has_opcode();
  inline void clear_has_opcode();
  inline void set_has_total_time();
  inline void clear_has_total_time();
  inline void set_has_single_step_time();
  inline void clear_has_single_step_time();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 src_user_locate_;
  ::google::protobuf::uint32 opcode_;
  ::google::protobuf::uint32 total_time_;
  ::google::protobuf::uint32 single_step_time_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static GameReadyReq* default_instance_;
};
// -------------------------------------------------------------------

class GameStatusReply : public ::google::protobuf::Message {
 public:
  GameStatusReply();
  virtual ~GameStatusReply();
  
  GameStatusReply(const GameStatusReply& from);
  
  inline GameStatusReply& operator=(const GameStatusReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameStatusReply& default_instance();
  
  void Swap(GameStatusReply* other);
  
  // implements Message ----------------------------------------------
  
  GameStatusReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameStatusReply& from);
  void MergeFrom(const GameStatusReply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool left_user_status = 1;
  inline bool has_left_user_status() const;
  inline void clear_left_user_status();
  static const int kLeftUserStatusFieldNumber = 1;
  inline bool left_user_status() const;
  inline void set_left_user_status(bool value);
  
  // required bool right_user_status = 2;
  inline bool has_right_user_status() const;
  inline void clear_right_user_status();
  static const int kRightUserStatusFieldNumber = 2;
  inline bool right_user_status() const;
  inline void set_right_user_status(bool value);
  
  // required bool bottom_user_status = 3;
  inline bool has_bottom_user_status() const;
  inline void clear_bottom_user_status();
  static const int kBottomUserStatusFieldNumber = 3;
  inline bool bottom_user_status() const;
  inline void set_bottom_user_status(bool value);
  
  // required uint32 token_locate = 4;
  inline bool has_token_locate() const;
  inline void clear_token_locate();
  static const int kTokenLocateFieldNumber = 4;
  inline ::google::protobuf::uint32 token_locate() const;
  inline void set_token_locate(::google::protobuf::uint32 value);
  
  // required uint32 total_time = 5;
  inline bool has_total_time() const;
  inline void clear_total_time();
  static const int kTotalTimeFieldNumber = 5;
  inline ::google::protobuf::uint32 total_time() const;
  inline void set_total_time(::google::protobuf::uint32 value);
  
  // required uint32 single_step_time = 6;
  inline bool has_single_step_time() const;
  inline void clear_single_step_time();
  static const int kSingleStepTimeFieldNumber = 6;
  inline ::google::protobuf::uint32 single_step_time() const;
  inline void set_single_step_time(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:MessageStruct.GameStatusReply)
 private:
  inline void set_has_left_user_status();
  inline void clear_has_left_user_status();
  inline void set_has_right_user_status();
  inline void clear_has_right_user_status();
  inline void set_has_bottom_user_status();
  inline void clear_has_bottom_user_status();
  inline void set_has_token_locate();
  inline void clear_has_token_locate();
  inline void set_has_total_time();
  inline void clear_has_total_time();
  inline void set_has_single_step_time();
  inline void clear_has_single_step_time();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool left_user_status_;
  bool right_user_status_;
  bool bottom_user_status_;
  ::google::protobuf::uint32 token_locate_;
  ::google::protobuf::uint32 total_time_;
  ::google::protobuf::uint32 single_step_time_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static GameStatusReply* default_instance_;
};
// -------------------------------------------------------------------

class FindPassword : public ::google::protobuf::Message {
 public:
  FindPassword();
  virtual ~FindPassword();
  
  FindPassword(const FindPassword& from);
  
  inline FindPassword& operator=(const FindPassword& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FindPassword& default_instance();
  
  void Swap(FindPassword* other);
  
  // implements Message ----------------------------------------------
  
  FindPassword* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FindPassword& from);
  void MergeFrom(const FindPassword& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string email = 1;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 1;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  
  // optional string opt = 2;
  inline bool has_opt() const;
  inline void clear_opt();
  static const int kOptFieldNumber = 2;
  inline const ::std::string& opt() const;
  inline void set_opt(const ::std::string& value);
  inline void set_opt(const char* value);
  inline void set_opt(const char* value, size_t size);
  inline ::std::string* mutable_opt();
  inline ::std::string* release_opt();
  
  // @@protoc_insertion_point(class_scope:MessageStruct.FindPassword)
 private:
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_opt();
  inline void clear_has_opt();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* email_;
  ::std::string* opt_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static FindPassword* default_instance_;
};
// -------------------------------------------------------------------

class UpdateUserInfo : public ::google::protobuf::Message {
 public:
  UpdateUserInfo();
  virtual ~UpdateUserInfo();
  
  UpdateUserInfo(const UpdateUserInfo& from);
  
  inline UpdateUserInfo& operator=(const UpdateUserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateUserInfo& default_instance();
  
  void Swap(UpdateUserInfo* other);
  
  // implements Message ----------------------------------------------
  
  UpdateUserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UpdateUserInfo& from);
  void MergeFrom(const UpdateUserInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  
  // required string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  
  // required string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // optional string ex_email = 4;
  inline bool has_ex_email() const;
  inline void clear_ex_email();
  static const int kExEmailFieldNumber = 4;
  inline const ::std::string& ex_email() const;
  inline void set_ex_email(const ::std::string& value);
  inline void set_ex_email(const char* value);
  inline void set_ex_email(const char* value, size_t size);
  inline ::std::string* mutable_ex_email();
  inline ::std::string* release_ex_email();
  
  // optional string phone = 5;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 5;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  
  // optional bytes head_image = 6;
  inline bool has_head_image() const;
  inline void clear_head_image();
  static const int kHeadImageFieldNumber = 6;
  inline const ::std::string& head_image() const;
  inline void set_head_image(const ::std::string& value);
  inline void set_head_image(const char* value);
  inline void set_head_image(const void* value, size_t size);
  inline ::std::string* mutable_head_image();
  inline ::std::string* release_head_image();
  
  // @@protoc_insertion_point(class_scope:MessageStruct.UpdateUserInfo)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_ex_email();
  inline void clear_has_ex_email();
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_head_image();
  inline void clear_has_head_image();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* user_name_;
  ::std::string* account_;
  ::std::string* password_;
  ::std::string* ex_email_;
  ::std::string* phone_;
  ::std::string* head_image_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static UpdateUserInfo* default_instance_;
};
// -------------------------------------------------------------------

class AdPictureItem : public ::google::protobuf::Message {
 public:
  AdPictureItem();
  virtual ~AdPictureItem();
  
  AdPictureItem(const AdPictureItem& from);
  
  inline AdPictureItem& operator=(const AdPictureItem& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AdPictureItem& default_instance();
  
  void Swap(AdPictureItem* other);
  
  // implements Message ----------------------------------------------
  
  AdPictureItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdPictureItem& from);
  void MergeFrom(const AdPictureItem& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 image_type = 1;
  inline bool has_image_type() const;
  inline void clear_image_type();
  static const int kImageTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 image_type() const;
  inline void set_image_type(::google::protobuf::uint32 value);
  
  // required string image_name = 2;
  inline bool has_image_name() const;
  inline void clear_image_name();
  static const int kImageNameFieldNumber = 2;
  inline const ::std::string& image_name() const;
  inline void set_image_name(const ::std::string& value);
  inline void set_image_name(const char* value);
  inline void set_image_name(const char* value, size_t size);
  inline ::std::string* mutable_image_name();
  inline ::std::string* release_image_name();
  
  // required bool existed = 3;
  inline bool has_existed() const;
  inline void clear_existed();
  static const int kExistedFieldNumber = 3;
  inline bool existed() const;
  inline void set_existed(bool value);
  
  // optional string image_hashcode = 4;
  inline bool has_image_hashcode() const;
  inline void clear_image_hashcode();
  static const int kImageHashcodeFieldNumber = 4;
  inline const ::std::string& image_hashcode() const;
  inline void set_image_hashcode(const ::std::string& value);
  inline void set_image_hashcode(const char* value);
  inline void set_image_hashcode(const char* value, size_t size);
  inline ::std::string* mutable_image_hashcode();
  inline ::std::string* release_image_hashcode();
  
  // optional string url = 5;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 5;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  
  // optional uint32 image_size = 6;
  inline bool has_image_size() const;
  inline void clear_image_size();
  static const int kImageSizeFieldNumber = 6;
  inline ::google::protobuf::uint32 image_size() const;
  inline void set_image_size(::google::protobuf::uint32 value);
  
  // required uint32 image_id = 7;
  inline bool has_image_id() const;
  inline void clear_image_id();
  static const int kImageIdFieldNumber = 7;
  inline ::google::protobuf::uint32 image_id() const;
  inline void set_image_id(::google::protobuf::uint32 value);
  
  // optional bool last_one = 8;
  inline bool has_last_one() const;
  inline void clear_last_one();
  static const int kLastOneFieldNumber = 8;
  inline bool last_one() const;
  inline void set_last_one(bool value);
  
  // @@protoc_insertion_point(class_scope:MessageStruct.AdPictureItem)
 private:
  inline void set_has_image_type();
  inline void clear_has_image_type();
  inline void set_has_image_name();
  inline void clear_has_image_name();
  inline void set_has_existed();
  inline void clear_has_existed();
  inline void set_has_image_hashcode();
  inline void clear_has_image_hashcode();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_image_size();
  inline void clear_has_image_size();
  inline void set_has_image_id();
  inline void clear_has_image_id();
  inline void set_has_last_one();
  inline void clear_has_last_one();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* image_name_;
  ::std::string* image_hashcode_;
  ::google::protobuf::uint32 image_type_;
  bool existed_;
  bool last_one_;
  ::std::string* url_;
  ::google::protobuf::uint32 image_size_;
  ::google::protobuf::uint32 image_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static AdPictureItem* default_instance_;
};
// -------------------------------------------------------------------

class AdPictureReply : public ::google::protobuf::Message {
 public:
  AdPictureReply();
  virtual ~AdPictureReply();
  
  AdPictureReply(const AdPictureReply& from);
  
  inline AdPictureReply& operator=(const AdPictureReply& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const AdPictureReply& default_instance();
  
  void Swap(AdPictureReply* other);
  
  // implements Message ----------------------------------------------
  
  AdPictureReply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdPictureReply& from);
  void MergeFrom(const AdPictureReply& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bool synced = 1;
  inline bool has_synced() const;
  inline void clear_synced();
  static const int kSyncedFieldNumber = 1;
  inline bool synced() const;
  inline void set_synced(bool value);
  
  // optional bytes content = 2;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 2;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const void* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  
  // optional bool ended = 3;
  inline bool has_ended() const;
  inline void clear_ended();
  static const int kEndedFieldNumber = 3;
  inline bool ended() const;
  inline void set_ended(bool value);
  
  // @@protoc_insertion_point(class_scope:MessageStruct.AdPictureReply)
 private:
  inline void set_has_synced();
  inline void clear_has_synced();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_ended();
  inline void clear_has_ended();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* content_;
  bool synced_;
  bool ended_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_message_2eproto();
  friend void protobuf_AssignDesc_message_2eproto();
  friend void protobuf_ShutdownFile_message_2eproto();
  
  void InitAsDefaultInstance();
  static AdPictureReply* default_instance_;
};
// ===================================================================


// ===================================================================

// Echo

// optional string time_stamp = 1;
inline bool Echo::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Echo::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Echo::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Echo::clear_time_stamp() {
  if (time_stamp_ != &::google::protobuf::internal::kEmptyString) {
    time_stamp_->clear();
  }
  clear_has_time_stamp();
}
inline const ::std::string& Echo::time_stamp() const {
  return *time_stamp_;
}
inline void Echo::set_time_stamp(const ::std::string& value) {
  set_has_time_stamp();
  if (time_stamp_ == &::google::protobuf::internal::kEmptyString) {
    time_stamp_ = new ::std::string;
  }
  time_stamp_->assign(value);
}
inline void Echo::set_time_stamp(const char* value) {
  set_has_time_stamp();
  if (time_stamp_ == &::google::protobuf::internal::kEmptyString) {
    time_stamp_ = new ::std::string;
  }
  time_stamp_->assign(value);
}
inline void Echo::set_time_stamp(const char* value, size_t size) {
  set_has_time_stamp();
  if (time_stamp_ == &::google::protobuf::internal::kEmptyString) {
    time_stamp_ = new ::std::string;
  }
  time_stamp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Echo::mutable_time_stamp() {
  set_has_time_stamp();
  if (time_stamp_ == &::google::protobuf::internal::kEmptyString) {
    time_stamp_ = new ::std::string;
  }
  return time_stamp_;
}
inline ::std::string* Echo::release_time_stamp() {
  clear_has_time_stamp();
  if (time_stamp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_stamp_;
    time_stamp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LogOnorOut

// required string account = 1;
inline bool LogOnorOut::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogOnorOut::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogOnorOut::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogOnorOut::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& LogOnorOut::account() const {
  return *account_;
}
inline void LogOnorOut::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void LogOnorOut::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void LogOnorOut::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogOnorOut::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* LogOnorOut::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string password = 2;
inline bool LogOnorOut::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogOnorOut::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogOnorOut::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogOnorOut::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& LogOnorOut::password() const {
  return *password_;
}
inline void LogOnorOut::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LogOnorOut::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void LogOnorOut::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LogOnorOut::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* LogOnorOut::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ReplyStatus

// required uint32 status = 1;
inline bool ReplyStatus::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReplyStatus::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReplyStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReplyStatus::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 ReplyStatus::status() const {
  return status_;
}
inline void ReplyStatus::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional .MessageStruct.ChessBoardUser user = 2;
inline bool ReplyStatus::has_user() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReplyStatus::set_has_user() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReplyStatus::clear_has_user() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReplyStatus::clear_user() {
  if (user_ != NULL) user_->::MessageStruct::ChessBoardUser::Clear();
  clear_has_user();
}
inline const ::MessageStruct::ChessBoardUser& ReplyStatus::user() const {
  return user_ != NULL ? *user_ : *default_instance_->user_;
}
inline ::MessageStruct::ChessBoardUser* ReplyStatus::mutable_user() {
  set_has_user();
  if (user_ == NULL) user_ = new ::MessageStruct::ChessBoardUser;
  return user_;
}
inline ::MessageStruct::ChessBoardUser* ReplyStatus::release_user() {
  clear_has_user();
  ::MessageStruct::ChessBoardUser* temp = user_;
  user_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Register

// required string email_account = 1;
inline bool Register::has_email_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Register::set_has_email_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Register::clear_has_email_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Register::clear_email_account() {
  if (email_account_ != &::google::protobuf::internal::kEmptyString) {
    email_account_->clear();
  }
  clear_has_email_account();
}
inline const ::std::string& Register::email_account() const {
  return *email_account_;
}
inline void Register::set_email_account(const ::std::string& value) {
  set_has_email_account();
  if (email_account_ == &::google::protobuf::internal::kEmptyString) {
    email_account_ = new ::std::string;
  }
  email_account_->assign(value);
}
inline void Register::set_email_account(const char* value) {
  set_has_email_account();
  if (email_account_ == &::google::protobuf::internal::kEmptyString) {
    email_account_ = new ::std::string;
  }
  email_account_->assign(value);
}
inline void Register::set_email_account(const char* value, size_t size) {
  set_has_email_account();
  if (email_account_ == &::google::protobuf::internal::kEmptyString) {
    email_account_ = new ::std::string;
  }
  email_account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register::mutable_email_account() {
  set_has_email_account();
  if (email_account_ == &::google::protobuf::internal::kEmptyString) {
    email_account_ = new ::std::string;
  }
  return email_account_;
}
inline ::std::string* Register::release_email_account() {
  clear_has_email_account();
  if (email_account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_account_;
    email_account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string password = 2;
inline bool Register::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Register::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Register::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Register::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& Register::password() const {
  return *password_;
}
inline void Register::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void Register::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void Register::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* Register::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string username = 3;
inline bool Register::has_username() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Register::set_has_username() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Register::clear_has_username() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Register::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& Register::username() const {
  return *username_;
}
inline void Register::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void Register::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void Register::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Register::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* Register::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ChessBoardUser

// required bool chess_board_empty = 1;
inline bool ChessBoardUser::has_chess_board_empty() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChessBoardUser::set_has_chess_board_empty() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChessBoardUser::clear_has_chess_board_empty() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChessBoardUser::clear_chess_board_empty() {
  chess_board_empty_ = false;
  clear_has_chess_board_empty();
}
inline bool ChessBoardUser::chess_board_empty() const {
  return chess_board_empty_;
}
inline void ChessBoardUser::set_chess_board_empty(bool value) {
  set_has_chess_board_empty();
  chess_board_empty_ = value;
}

// optional string user_name = 2;
inline bool ChessBoardUser::has_user_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChessBoardUser::set_has_user_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChessBoardUser::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChessBoardUser::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& ChessBoardUser::user_name() const {
  return *user_name_;
}
inline void ChessBoardUser::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void ChessBoardUser::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void ChessBoardUser::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChessBoardUser::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* ChessBoardUser::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string account = 3;
inline bool ChessBoardUser::has_account() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChessBoardUser::set_has_account() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChessBoardUser::clear_has_account() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChessBoardUser::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& ChessBoardUser::account() const {
  return *account_;
}
inline void ChessBoardUser::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ChessBoardUser::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ChessBoardUser::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChessBoardUser::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* ChessBoardUser::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 score = 4;
inline bool ChessBoardUser::has_score() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChessBoardUser::set_has_score() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChessBoardUser::clear_has_score() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChessBoardUser::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 ChessBoardUser::score() const {
  return score_;
}
inline void ChessBoardUser::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
}

// optional string ex_email = 5;
inline bool ChessBoardUser::has_ex_email() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChessBoardUser::set_has_ex_email() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChessBoardUser::clear_has_ex_email() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChessBoardUser::clear_ex_email() {
  if (ex_email_ != &::google::protobuf::internal::kEmptyString) {
    ex_email_->clear();
  }
  clear_has_ex_email();
}
inline const ::std::string& ChessBoardUser::ex_email() const {
  return *ex_email_;
}
inline void ChessBoardUser::set_ex_email(const ::std::string& value) {
  set_has_ex_email();
  if (ex_email_ == &::google::protobuf::internal::kEmptyString) {
    ex_email_ = new ::std::string;
  }
  ex_email_->assign(value);
}
inline void ChessBoardUser::set_ex_email(const char* value) {
  set_has_ex_email();
  if (ex_email_ == &::google::protobuf::internal::kEmptyString) {
    ex_email_ = new ::std::string;
  }
  ex_email_->assign(value);
}
inline void ChessBoardUser::set_ex_email(const char* value, size_t size) {
  set_has_ex_email();
  if (ex_email_ == &::google::protobuf::internal::kEmptyString) {
    ex_email_ = new ::std::string;
  }
  ex_email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChessBoardUser::mutable_ex_email() {
  set_has_ex_email();
  if (ex_email_ == &::google::protobuf::internal::kEmptyString) {
    ex_email_ = new ::std::string;
  }
  return ex_email_;
}
inline ::std::string* ChessBoardUser::release_ex_email() {
  clear_has_ex_email();
  if (ex_email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ex_email_;
    ex_email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string phone = 6;
inline bool ChessBoardUser::has_phone() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ChessBoardUser::set_has_phone() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ChessBoardUser::clear_has_phone() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ChessBoardUser::clear_phone() {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& ChessBoardUser::phone() const {
  return *phone_;
}
inline void ChessBoardUser::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void ChessBoardUser::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void ChessBoardUser::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChessBoardUser::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  return phone_;
}
inline ::std::string* ChessBoardUser::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes head_image = 7;
inline bool ChessBoardUser::has_head_image() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ChessBoardUser::set_has_head_image() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ChessBoardUser::clear_has_head_image() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ChessBoardUser::clear_head_image() {
  if (head_image_ != &::google::protobuf::internal::kEmptyString) {
    head_image_->clear();
  }
  clear_has_head_image();
}
inline const ::std::string& ChessBoardUser::head_image() const {
  return *head_image_;
}
inline void ChessBoardUser::set_head_image(const ::std::string& value) {
  set_has_head_image();
  if (head_image_ == &::google::protobuf::internal::kEmptyString) {
    head_image_ = new ::std::string;
  }
  head_image_->assign(value);
}
inline void ChessBoardUser::set_head_image(const char* value) {
  set_has_head_image();
  if (head_image_ == &::google::protobuf::internal::kEmptyString) {
    head_image_ = new ::std::string;
  }
  head_image_->assign(value);
}
inline void ChessBoardUser::set_head_image(const void* value, size_t size) {
  set_has_head_image();
  if (head_image_ == &::google::protobuf::internal::kEmptyString) {
    head_image_ = new ::std::string;
  }
  head_image_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChessBoardUser::mutable_head_image() {
  set_has_head_image();
  if (head_image_ == &::google::protobuf::internal::kEmptyString) {
    head_image_ = new ::std::string;
  }
  return head_image_;
}
inline ::std::string* ChessBoardUser::release_head_image() {
  clear_has_head_image();
  if (head_image_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = head_image_;
    head_image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 status = 8;
inline bool ChessBoardUser::has_status() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ChessBoardUser::set_has_status() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ChessBoardUser::clear_has_status() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ChessBoardUser::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 ChessBoardUser::status() const {
  return status_;
}
inline void ChessBoardUser::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// ChessBoardInfoReq

// required int32 chess_board_id = 1;
inline bool ChessBoardInfoReq::has_chess_board_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChessBoardInfoReq::set_has_chess_board_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChessBoardInfoReq::clear_has_chess_board_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChessBoardInfoReq::clear_chess_board_id() {
  chess_board_id_ = 0;
  clear_has_chess_board_id();
}
inline ::google::protobuf::int32 ChessBoardInfoReq::chess_board_id() const {
  return chess_board_id_;
}
inline void ChessBoardInfoReq::set_chess_board_id(::google::protobuf::int32 value) {
  set_has_chess_board_id();
  chess_board_id_ = value;
}

// optional int32 opcode = 2;
inline bool ChessBoardInfoReq::has_opcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChessBoardInfoReq::set_has_opcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChessBoardInfoReq::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChessBoardInfoReq::clear_opcode() {
  opcode_ = 0;
  clear_has_opcode();
}
inline ::google::protobuf::int32 ChessBoardInfoReq::opcode() const {
  return opcode_;
}
inline void ChessBoardInfoReq::set_opcode(::google::protobuf::int32 value) {
  set_has_opcode();
  opcode_ = value;
}

// -------------------------------------------------------------------

// ChessBoardInfo

// required uint32 id = 1;
inline bool ChessBoardInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChessBoardInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChessBoardInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChessBoardInfo::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 ChessBoardInfo::id() const {
  return id_;
}
inline void ChessBoardInfo::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 people_num = 2;
inline bool ChessBoardInfo::has_people_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChessBoardInfo::set_has_people_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChessBoardInfo::clear_has_people_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChessBoardInfo::clear_people_num() {
  people_num_ = 0u;
  clear_has_people_num();
}
inline ::google::protobuf::uint32 ChessBoardInfo::people_num() const {
  return people_num_;
}
inline void ChessBoardInfo::set_people_num(::google::protobuf::uint32 value) {
  set_has_people_num();
  people_num_ = value;
}

// required .MessageStruct.ChessBoardUser left_user = 3;
inline bool ChessBoardInfo::has_left_user() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChessBoardInfo::set_has_left_user() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChessBoardInfo::clear_has_left_user() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChessBoardInfo::clear_left_user() {
  if (left_user_ != NULL) left_user_->::MessageStruct::ChessBoardUser::Clear();
  clear_has_left_user();
}
inline const ::MessageStruct::ChessBoardUser& ChessBoardInfo::left_user() const {
  return left_user_ != NULL ? *left_user_ : *default_instance_->left_user_;
}
inline ::MessageStruct::ChessBoardUser* ChessBoardInfo::mutable_left_user() {
  set_has_left_user();
  if (left_user_ == NULL) left_user_ = new ::MessageStruct::ChessBoardUser;
  return left_user_;
}
inline ::MessageStruct::ChessBoardUser* ChessBoardInfo::release_left_user() {
  clear_has_left_user();
  ::MessageStruct::ChessBoardUser* temp = left_user_;
  left_user_ = NULL;
  return temp;
}

// required .MessageStruct.ChessBoardUser right_user = 4;
inline bool ChessBoardInfo::has_right_user() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChessBoardInfo::set_has_right_user() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChessBoardInfo::clear_has_right_user() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChessBoardInfo::clear_right_user() {
  if (right_user_ != NULL) right_user_->::MessageStruct::ChessBoardUser::Clear();
  clear_has_right_user();
}
inline const ::MessageStruct::ChessBoardUser& ChessBoardInfo::right_user() const {
  return right_user_ != NULL ? *right_user_ : *default_instance_->right_user_;
}
inline ::MessageStruct::ChessBoardUser* ChessBoardInfo::mutable_right_user() {
  set_has_right_user();
  if (right_user_ == NULL) right_user_ = new ::MessageStruct::ChessBoardUser;
  return right_user_;
}
inline ::MessageStruct::ChessBoardUser* ChessBoardInfo::release_right_user() {
  clear_has_right_user();
  ::MessageStruct::ChessBoardUser* temp = right_user_;
  right_user_ = NULL;
  return temp;
}

// required .MessageStruct.ChessBoardUser bottom_user = 5;
inline bool ChessBoardInfo::has_bottom_user() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChessBoardInfo::set_has_bottom_user() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChessBoardInfo::clear_has_bottom_user() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChessBoardInfo::clear_bottom_user() {
  if (bottom_user_ != NULL) bottom_user_->::MessageStruct::ChessBoardUser::Clear();
  clear_has_bottom_user();
}
inline const ::MessageStruct::ChessBoardUser& ChessBoardInfo::bottom_user() const {
  return bottom_user_ != NULL ? *bottom_user_ : *default_instance_->bottom_user_;
}
inline ::MessageStruct::ChessBoardUser* ChessBoardInfo::mutable_bottom_user() {
  set_has_bottom_user();
  if (bottom_user_ == NULL) bottom_user_ = new ::MessageStruct::ChessBoardUser;
  return bottom_user_;
}
inline ::MessageStruct::ChessBoardUser* ChessBoardInfo::release_bottom_user() {
  clear_has_bottom_user();
  ::MessageStruct::ChessBoardUser* temp = bottom_user_;
  bottom_user_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// HallInfoReq

// required int32 game_hall_id = 1;
inline bool HallInfoReq::has_game_hall_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HallInfoReq::set_has_game_hall_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HallInfoReq::clear_has_game_hall_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HallInfoReq::clear_game_hall_id() {
  game_hall_id_ = 0;
  clear_has_game_hall_id();
}
inline ::google::protobuf::int32 HallInfoReq::game_hall_id() const {
  return game_hall_id_;
}
inline void HallInfoReq::set_game_hall_id(::google::protobuf::int32 value) {
  set_has_game_hall_id();
  game_hall_id_ = value;
}

// optional int32 opcode = 2;
inline bool HallInfoReq::has_opcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HallInfoReq::set_has_opcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HallInfoReq::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HallInfoReq::clear_opcode() {
  opcode_ = 0;
  clear_has_opcode();
}
inline ::google::protobuf::int32 HallInfoReq::opcode() const {
  return opcode_;
}
inline void HallInfoReq::set_opcode(::google::protobuf::int32 value) {
  set_has_opcode();
  opcode_ = value;
}

// -------------------------------------------------------------------

// HallInfo

// required int32 game_hall_id = 1;
inline bool HallInfo::has_game_hall_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HallInfo::set_has_game_hall_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HallInfo::clear_has_game_hall_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HallInfo::clear_game_hall_id() {
  game_hall_id_ = 0;
  clear_has_game_hall_id();
}
inline ::google::protobuf::int32 HallInfo::game_hall_id() const {
  return game_hall_id_;
}
inline void HallInfo::set_game_hall_id(::google::protobuf::int32 value) {
  set_has_game_hall_id();
  game_hall_id_ = value;
}

// required uint32 total_people = 2;
inline bool HallInfo::has_total_people() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HallInfo::set_has_total_people() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HallInfo::clear_has_total_people() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HallInfo::clear_total_people() {
  total_people_ = 0u;
  clear_has_total_people();
}
inline ::google::protobuf::uint32 HallInfo::total_people() const {
  return total_people_;
}
inline void HallInfo::set_total_people(::google::protobuf::uint32 value) {
  set_has_total_people();
  total_people_ = value;
}

// required uint32 curr_people = 3;
inline bool HallInfo::has_curr_people() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HallInfo::set_has_curr_people() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HallInfo::clear_has_curr_people() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HallInfo::clear_curr_people() {
  curr_people_ = 0u;
  clear_has_curr_people();
}
inline ::google::protobuf::uint32 HallInfo::curr_people() const {
  return curr_people_;
}
inline void HallInfo::set_curr_people(::google::protobuf::uint32 value) {
  set_has_curr_people();
  curr_people_ = value;
}

// optional uint32 total_chessboard = 4;
inline bool HallInfo::has_total_chessboard() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HallInfo::set_has_total_chessboard() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HallInfo::clear_has_total_chessboard() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HallInfo::clear_total_chessboard() {
  total_chessboard_ = 0u;
  clear_has_total_chessboard();
}
inline ::google::protobuf::uint32 HallInfo::total_chessboard() const {
  return total_chessboard_;
}
inline void HallInfo::set_total_chessboard(::google::protobuf::uint32 value) {
  set_has_total_chessboard();
  total_chessboard_ = value;
}

// repeated .MessageStruct.ChessBoardInfo chess_board = 5;
inline int HallInfo::chess_board_size() const {
  return chess_board_.size();
}
inline void HallInfo::clear_chess_board() {
  chess_board_.Clear();
}
inline const ::MessageStruct::ChessBoardInfo& HallInfo::chess_board(int index) const {
  return chess_board_.Get(index);
}
inline ::MessageStruct::ChessBoardInfo* HallInfo::mutable_chess_board(int index) {
  return chess_board_.Mutable(index);
}
inline ::MessageStruct::ChessBoardInfo* HallInfo::add_chess_board() {
  return chess_board_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MessageStruct::ChessBoardInfo >&
HallInfo::chess_board() const {
  return chess_board_;
}
inline ::google::protobuf::RepeatedPtrField< ::MessageStruct::ChessBoardInfo >*
HallInfo::mutable_chess_board() {
  return &chess_board_;
}

// -------------------------------------------------------------------

// GameHallSumaryReq

// optional int32 opcode = 1;
inline bool GameHallSumaryReq::has_opcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameHallSumaryReq::set_has_opcode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameHallSumaryReq::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameHallSumaryReq::clear_opcode() {
  opcode_ = 0;
  clear_has_opcode();
}
inline ::google::protobuf::int32 GameHallSumaryReq::opcode() const {
  return opcode_;
}
inline void GameHallSumaryReq::set_opcode(::google::protobuf::int32 value) {
  set_has_opcode();
  opcode_ = value;
}

// -------------------------------------------------------------------

// GameHallSumary

// required string account = 1;
inline bool GameHallSumary::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameHallSumary::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameHallSumary::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameHallSumary::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& GameHallSumary::account() const {
  return *account_;
}
inline void GameHallSumary::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void GameHallSumary::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void GameHallSumary::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameHallSumary::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* GameHallSumary::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string username = 2;
inline bool GameHallSumary::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameHallSumary::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameHallSumary::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameHallSumary::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& GameHallSumary::username() const {
  return *username_;
}
inline void GameHallSumary::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void GameHallSumary::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void GameHallSumary::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameHallSumary::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* GameHallSumary::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 score = 3;
inline bool GameHallSumary::has_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameHallSumary::set_has_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameHallSumary::clear_has_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameHallSumary::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 GameHallSumary::score() const {
  return score_;
}
inline void GameHallSumary::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
}

// required uint32 hall_num = 4;
inline bool GameHallSumary::has_hall_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameHallSumary::set_has_hall_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameHallSumary::clear_has_hall_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameHallSumary::clear_hall_num() {
  hall_num_ = 0u;
  clear_has_hall_num();
}
inline ::google::protobuf::uint32 GameHallSumary::hall_num() const {
  return hall_num_;
}
inline void GameHallSumary::set_hall_num(::google::protobuf::uint32 value) {
  set_has_hall_num();
  hall_num_ = value;
}

// required string head_picture = 5;
inline bool GameHallSumary::has_head_picture() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameHallSumary::set_has_head_picture() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameHallSumary::clear_has_head_picture() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameHallSumary::clear_head_picture() {
  if (head_picture_ != &::google::protobuf::internal::kEmptyString) {
    head_picture_->clear();
  }
  clear_has_head_picture();
}
inline const ::std::string& GameHallSumary::head_picture() const {
  return *head_picture_;
}
inline void GameHallSumary::set_head_picture(const ::std::string& value) {
  set_has_head_picture();
  if (head_picture_ == &::google::protobuf::internal::kEmptyString) {
    head_picture_ = new ::std::string;
  }
  head_picture_->assign(value);
}
inline void GameHallSumary::set_head_picture(const char* value) {
  set_has_head_picture();
  if (head_picture_ == &::google::protobuf::internal::kEmptyString) {
    head_picture_ = new ::std::string;
  }
  head_picture_->assign(value);
}
inline void GameHallSumary::set_head_picture(const char* value, size_t size) {
  set_has_head_picture();
  if (head_picture_ == &::google::protobuf::internal::kEmptyString) {
    head_picture_ = new ::std::string;
  }
  head_picture_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameHallSumary::mutable_head_picture() {
  set_has_head_picture();
  if (head_picture_ == &::google::protobuf::internal::kEmptyString) {
    head_picture_ = new ::std::string;
  }
  return head_picture_;
}
inline ::std::string* GameHallSumary::release_head_picture() {
  clear_has_head_picture();
  if (head_picture_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = head_picture_;
    head_picture_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string ad_picture1 = 6;
inline bool GameHallSumary::has_ad_picture1() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameHallSumary::set_has_ad_picture1() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameHallSumary::clear_has_ad_picture1() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameHallSumary::clear_ad_picture1() {
  if (ad_picture1_ != &::google::protobuf::internal::kEmptyString) {
    ad_picture1_->clear();
  }
  clear_has_ad_picture1();
}
inline const ::std::string& GameHallSumary::ad_picture1() const {
  return *ad_picture1_;
}
inline void GameHallSumary::set_ad_picture1(const ::std::string& value) {
  set_has_ad_picture1();
  if (ad_picture1_ == &::google::protobuf::internal::kEmptyString) {
    ad_picture1_ = new ::std::string;
  }
  ad_picture1_->assign(value);
}
inline void GameHallSumary::set_ad_picture1(const char* value) {
  set_has_ad_picture1();
  if (ad_picture1_ == &::google::protobuf::internal::kEmptyString) {
    ad_picture1_ = new ::std::string;
  }
  ad_picture1_->assign(value);
}
inline void GameHallSumary::set_ad_picture1(const char* value, size_t size) {
  set_has_ad_picture1();
  if (ad_picture1_ == &::google::protobuf::internal::kEmptyString) {
    ad_picture1_ = new ::std::string;
  }
  ad_picture1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameHallSumary::mutable_ad_picture1() {
  set_has_ad_picture1();
  if (ad_picture1_ == &::google::protobuf::internal::kEmptyString) {
    ad_picture1_ = new ::std::string;
  }
  return ad_picture1_;
}
inline ::std::string* GameHallSumary::release_ad_picture1() {
  clear_has_ad_picture1();
  if (ad_picture1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ad_picture1_;
    ad_picture1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ad_picture2 = 7;
inline bool GameHallSumary::has_ad_picture2() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GameHallSumary::set_has_ad_picture2() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GameHallSumary::clear_has_ad_picture2() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GameHallSumary::clear_ad_picture2() {
  if (ad_picture2_ != &::google::protobuf::internal::kEmptyString) {
    ad_picture2_->clear();
  }
  clear_has_ad_picture2();
}
inline const ::std::string& GameHallSumary::ad_picture2() const {
  return *ad_picture2_;
}
inline void GameHallSumary::set_ad_picture2(const ::std::string& value) {
  set_has_ad_picture2();
  if (ad_picture2_ == &::google::protobuf::internal::kEmptyString) {
    ad_picture2_ = new ::std::string;
  }
  ad_picture2_->assign(value);
}
inline void GameHallSumary::set_ad_picture2(const char* value) {
  set_has_ad_picture2();
  if (ad_picture2_ == &::google::protobuf::internal::kEmptyString) {
    ad_picture2_ = new ::std::string;
  }
  ad_picture2_->assign(value);
}
inline void GameHallSumary::set_ad_picture2(const char* value, size_t size) {
  set_has_ad_picture2();
  if (ad_picture2_ == &::google::protobuf::internal::kEmptyString) {
    ad_picture2_ = new ::std::string;
  }
  ad_picture2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameHallSumary::mutable_ad_picture2() {
  set_has_ad_picture2();
  if (ad_picture2_ == &::google::protobuf::internal::kEmptyString) {
    ad_picture2_ = new ::std::string;
  }
  return ad_picture2_;
}
inline ::std::string* GameHallSumary::release_ad_picture2() {
  clear_has_ad_picture2();
  if (ad_picture2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ad_picture2_;
    ad_picture2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .MessageStruct.HallInfo hall_info = 8;
inline int GameHallSumary::hall_info_size() const {
  return hall_info_.size();
}
inline void GameHallSumary::clear_hall_info() {
  hall_info_.Clear();
}
inline const ::MessageStruct::HallInfo& GameHallSumary::hall_info(int index) const {
  return hall_info_.Get(index);
}
inline ::MessageStruct::HallInfo* GameHallSumary::mutable_hall_info(int index) {
  return hall_info_.Mutable(index);
}
inline ::MessageStruct::HallInfo* GameHallSumary::add_hall_info() {
  return hall_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MessageStruct::HallInfo >&
GameHallSumary::hall_info() const {
  return hall_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::MessageStruct::HallInfo >*
GameHallSumary::mutable_hall_info() {
  return &hall_info_;
}

// -------------------------------------------------------------------

// RequestPlay

// required int32 game_hall_id = 1;
inline bool RequestPlay::has_game_hall_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestPlay::set_has_game_hall_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestPlay::clear_has_game_hall_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestPlay::clear_game_hall_id() {
  game_hall_id_ = 0;
  clear_has_game_hall_id();
}
inline ::google::protobuf::int32 RequestPlay::game_hall_id() const {
  return game_hall_id_;
}
inline void RequestPlay::set_game_hall_id(::google::protobuf::int32 value) {
  set_has_game_hall_id();
  game_hall_id_ = value;
}

// required int32 chess_board_id = 2;
inline bool RequestPlay::has_chess_board_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestPlay::set_has_chess_board_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestPlay::clear_has_chess_board_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestPlay::clear_chess_board_id() {
  chess_board_id_ = 0;
  clear_has_chess_board_id();
}
inline ::google::protobuf::int32 RequestPlay::chess_board_id() const {
  return chess_board_id_;
}
inline void RequestPlay::set_chess_board_id(::google::protobuf::int32 value) {
  set_has_chess_board_id();
  chess_board_id_ = value;
}

// required int32 locate = 3;
inline bool RequestPlay::has_locate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestPlay::set_has_locate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestPlay::clear_has_locate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestPlay::clear_locate() {
  locate_ = 0;
  clear_has_locate();
}
inline ::google::protobuf::int32 RequestPlay::locate() const {
  return locate_;
}
inline void RequestPlay::set_locate(::google::protobuf::int32 value) {
  set_has_locate();
  locate_ = value;
}

// -------------------------------------------------------------------

// RequestPlayReply

// required int32 status = 1;
inline bool RequestPlayReply::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequestPlayReply::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequestPlayReply::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequestPlayReply::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 RequestPlayReply::status() const {
  return status_;
}
inline void RequestPlayReply::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// required uint32 first_come_user_locate = 2;
inline bool RequestPlayReply::has_first_come_user_locate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequestPlayReply::set_has_first_come_user_locate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequestPlayReply::clear_has_first_come_user_locate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequestPlayReply::clear_first_come_user_locate() {
  first_come_user_locate_ = 0u;
  clear_has_first_come_user_locate();
}
inline ::google::protobuf::uint32 RequestPlayReply::first_come_user_locate() const {
  return first_come_user_locate_;
}
inline void RequestPlayReply::set_first_come_user_locate(::google::protobuf::uint32 value) {
  set_has_first_come_user_locate();
  first_come_user_locate_ = value;
}

// optional .MessageStruct.ChessBoardInfo chessBoard = 3;
inline bool RequestPlayReply::has_chessboard() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequestPlayReply::set_has_chessboard() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequestPlayReply::clear_has_chessboard() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequestPlayReply::clear_chessboard() {
  if (chessboard_ != NULL) chessboard_->::MessageStruct::ChessBoardInfo::Clear();
  clear_has_chessboard();
}
inline const ::MessageStruct::ChessBoardInfo& RequestPlayReply::chessboard() const {
  return chessboard_ != NULL ? *chessboard_ : *default_instance_->chessboard_;
}
inline ::MessageStruct::ChessBoardInfo* RequestPlayReply::mutable_chessboard() {
  set_has_chessboard();
  if (chessboard_ == NULL) chessboard_ = new ::MessageStruct::ChessBoardInfo;
  return chessboard_;
}
inline ::MessageStruct::ChessBoardInfo* RequestPlayReply::release_chessboard() {
  clear_has_chessboard();
  ::MessageStruct::ChessBoardInfo* temp = chessboard_;
  chessboard_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// MoveChess

// required int32 src_chess_type = 1;
inline bool MoveChess::has_src_chess_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoveChess::set_has_src_chess_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoveChess::clear_has_src_chess_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoveChess::clear_src_chess_type() {
  src_chess_type_ = 0;
  clear_has_src_chess_type();
}
inline ::google::protobuf::int32 MoveChess::src_chess_type() const {
  return src_chess_type_;
}
inline void MoveChess::set_src_chess_type(::google::protobuf::int32 value) {
  set_has_src_chess_type();
  src_chess_type_ = value;
}

// required int32 src_user_locate = 2;
inline bool MoveChess::has_src_user_locate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoveChess::set_has_src_user_locate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoveChess::clear_has_src_user_locate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoveChess::clear_src_user_locate() {
  src_user_locate_ = 0;
  clear_has_src_user_locate();
}
inline ::google::protobuf::int32 MoveChess::src_user_locate() const {
  return src_user_locate_;
}
inline void MoveChess::set_src_user_locate(::google::protobuf::int32 value) {
  set_has_src_user_locate();
  src_user_locate_ = value;
}

// required int32 from_pointX = 3;
inline bool MoveChess::has_from_pointx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoveChess::set_has_from_pointx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoveChess::clear_has_from_pointx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MoveChess::clear_from_pointx() {
  from_pointx_ = 0;
  clear_has_from_pointx();
}
inline ::google::protobuf::int32 MoveChess::from_pointx() const {
  return from_pointx_;
}
inline void MoveChess::set_from_pointx(::google::protobuf::int32 value) {
  set_has_from_pointx();
  from_pointx_ = value;
}

// required int32 from_pointY = 4;
inline bool MoveChess::has_from_pointy() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MoveChess::set_has_from_pointy() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MoveChess::clear_has_from_pointy() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MoveChess::clear_from_pointy() {
  from_pointy_ = 0;
  clear_has_from_pointy();
}
inline ::google::protobuf::int32 MoveChess::from_pointy() const {
  return from_pointy_;
}
inline void MoveChess::set_from_pointy(::google::protobuf::int32 value) {
  set_has_from_pointy();
  from_pointy_ = value;
}

// required int32 des_pointX = 5;
inline bool MoveChess::has_des_pointx() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MoveChess::set_has_des_pointx() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MoveChess::clear_has_des_pointx() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MoveChess::clear_des_pointx() {
  des_pointx_ = 0;
  clear_has_des_pointx();
}
inline ::google::protobuf::int32 MoveChess::des_pointx() const {
  return des_pointx_;
}
inline void MoveChess::set_des_pointx(::google::protobuf::int32 value) {
  set_has_des_pointx();
  des_pointx_ = value;
}

// required int32 des_pointY = 6;
inline bool MoveChess::has_des_pointy() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MoveChess::set_has_des_pointy() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MoveChess::clear_has_des_pointy() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MoveChess::clear_des_pointy() {
  des_pointy_ = 0;
  clear_has_des_pointy();
}
inline ::google::protobuf::int32 MoveChess::des_pointy() const {
  return des_pointy_;
}
inline void MoveChess::set_des_pointy(::google::protobuf::int32 value) {
  set_has_des_pointy();
  des_pointy_ = value;
}

// required bool is_winner = 7;
inline bool MoveChess::has_is_winner() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MoveChess::set_has_is_winner() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MoveChess::clear_has_is_winner() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MoveChess::clear_is_winner() {
  is_winner_ = false;
  clear_has_is_winner();
}
inline bool MoveChess::is_winner() const {
  return is_winner_;
}
inline void MoveChess::set_is_winner(bool value) {
  set_has_is_winner();
  is_winner_ = value;
}

// optional int32 eat_target_chess_type = 8;
inline bool MoveChess::has_eat_target_chess_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MoveChess::set_has_eat_target_chess_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MoveChess::clear_has_eat_target_chess_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MoveChess::clear_eat_target_chess_type() {
  eat_target_chess_type_ = 0;
  clear_has_eat_target_chess_type();
}
inline ::google::protobuf::int32 MoveChess::eat_target_chess_type() const {
  return eat_target_chess_type_;
}
inline void MoveChess::set_eat_target_chess_type(::google::protobuf::int32 value) {
  set_has_eat_target_chess_type();
  eat_target_chess_type_ = value;
}

// optional uint32 target_user_locate = 9;
inline bool MoveChess::has_target_user_locate() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MoveChess::set_has_target_user_locate() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MoveChess::clear_has_target_user_locate() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MoveChess::clear_target_user_locate() {
  target_user_locate_ = 0u;
  clear_has_target_user_locate();
}
inline ::google::protobuf::uint32 MoveChess::target_user_locate() const {
  return target_user_locate_;
}
inline void MoveChess::set_target_user_locate(::google::protobuf::uint32 value) {
  set_has_target_user_locate();
  target_user_locate_ = value;
}

// -------------------------------------------------------------------

// MoveAction

// required uint32 src_user_locate = 1;
inline bool MoveAction::has_src_user_locate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MoveAction::set_has_src_user_locate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MoveAction::clear_has_src_user_locate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MoveAction::clear_src_user_locate() {
  src_user_locate_ = 0u;
  clear_has_src_user_locate();
}
inline ::google::protobuf::uint32 MoveAction::src_user_locate() const {
  return src_user_locate_;
}
inline void MoveAction::set_src_user_locate(::google::protobuf::uint32 value) {
  set_has_src_user_locate();
  src_user_locate_ = value;
}

// required .MessageStruct.MoveChess movechess = 2;
inline bool MoveAction::has_movechess() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MoveAction::set_has_movechess() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MoveAction::clear_has_movechess() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MoveAction::clear_movechess() {
  if (movechess_ != NULL) movechess_->::MessageStruct::MoveChess::Clear();
  clear_has_movechess();
}
inline const ::MessageStruct::MoveChess& MoveAction::movechess() const {
  return movechess_ != NULL ? *movechess_ : *default_instance_->movechess_;
}
inline ::MessageStruct::MoveChess* MoveAction::mutable_movechess() {
  set_has_movechess();
  if (movechess_ == NULL) movechess_ = new ::MessageStruct::MoveChess;
  return movechess_;
}
inline ::MessageStruct::MoveChess* MoveAction::release_movechess() {
  clear_has_movechess();
  ::MessageStruct::MoveChess* temp = movechess_;
  movechess_ = NULL;
  return temp;
}

// required uint32 token_locate = 3;
inline bool MoveAction::has_token_locate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MoveAction::set_has_token_locate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MoveAction::clear_has_token_locate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MoveAction::clear_token_locate() {
  token_locate_ = 0u;
  clear_has_token_locate();
}
inline ::google::protobuf::uint32 MoveAction::token_locate() const {
  return token_locate_;
}
inline void MoveAction::set_token_locate(::google::protobuf::uint32 value) {
  set_has_token_locate();
  token_locate_ = value;
}

// -------------------------------------------------------------------

// UserMessage

// required uint32 src_user_locate = 1;
inline bool UserMessage::has_src_user_locate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserMessage::set_has_src_user_locate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserMessage::clear_has_src_user_locate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserMessage::clear_src_user_locate() {
  src_user_locate_ = 0u;
  clear_has_src_user_locate();
}
inline ::google::protobuf::uint32 UserMessage::src_user_locate() const {
  return src_user_locate_;
}
inline void UserMessage::set_src_user_locate(::google::protobuf::uint32 value) {
  set_has_src_user_locate();
  src_user_locate_ = value;
}

// required string msgContent = 2;
inline bool UserMessage::has_msgcontent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserMessage::set_has_msgcontent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserMessage::clear_has_msgcontent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserMessage::clear_msgcontent() {
  if (msgcontent_ != &::google::protobuf::internal::kEmptyString) {
    msgcontent_->clear();
  }
  clear_has_msgcontent();
}
inline const ::std::string& UserMessage::msgcontent() const {
  return *msgcontent_;
}
inline void UserMessage::set_msgcontent(const ::std::string& value) {
  set_has_msgcontent();
  if (msgcontent_ == &::google::protobuf::internal::kEmptyString) {
    msgcontent_ = new ::std::string;
  }
  msgcontent_->assign(value);
}
inline void UserMessage::set_msgcontent(const char* value) {
  set_has_msgcontent();
  if (msgcontent_ == &::google::protobuf::internal::kEmptyString) {
    msgcontent_ = new ::std::string;
  }
  msgcontent_->assign(value);
}
inline void UserMessage::set_msgcontent(const char* value, size_t size) {
  set_has_msgcontent();
  if (msgcontent_ == &::google::protobuf::internal::kEmptyString) {
    msgcontent_ = new ::std::string;
  }
  msgcontent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserMessage::mutable_msgcontent() {
  set_has_msgcontent();
  if (msgcontent_ == &::google::protobuf::internal::kEmptyString) {
    msgcontent_ = new ::std::string;
  }
  return msgcontent_;
}
inline ::std::string* UserMessage::release_msgcontent() {
  clear_has_msgcontent();
  if (msgcontent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msgcontent_;
    msgcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// SystemMessage

// required string msgContent = 1;
inline bool SystemMessage::has_msgcontent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemMessage::set_has_msgcontent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemMessage::clear_has_msgcontent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemMessage::clear_msgcontent() {
  if (msgcontent_ != &::google::protobuf::internal::kEmptyString) {
    msgcontent_->clear();
  }
  clear_has_msgcontent();
}
inline const ::std::string& SystemMessage::msgcontent() const {
  return *msgcontent_;
}
inline void SystemMessage::set_msgcontent(const ::std::string& value) {
  set_has_msgcontent();
  if (msgcontent_ == &::google::protobuf::internal::kEmptyString) {
    msgcontent_ = new ::std::string;
  }
  msgcontent_->assign(value);
}
inline void SystemMessage::set_msgcontent(const char* value) {
  set_has_msgcontent();
  if (msgcontent_ == &::google::protobuf::internal::kEmptyString) {
    msgcontent_ = new ::std::string;
  }
  msgcontent_->assign(value);
}
inline void SystemMessage::set_msgcontent(const char* value, size_t size) {
  set_has_msgcontent();
  if (msgcontent_ == &::google::protobuf::internal::kEmptyString) {
    msgcontent_ = new ::std::string;
  }
  msgcontent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SystemMessage::mutable_msgcontent() {
  set_has_msgcontent();
  if (msgcontent_ == &::google::protobuf::internal::kEmptyString) {
    msgcontent_ = new ::std::string;
  }
  return msgcontent_;
}
inline ::std::string* SystemMessage::release_msgcontent() {
  clear_has_msgcontent();
  if (msgcontent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msgcontent_;
    msgcontent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Reconciled

// required uint32 apply_or_reply = 1;
inline bool Reconciled::has_apply_or_reply() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Reconciled::set_has_apply_or_reply() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Reconciled::clear_has_apply_or_reply() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Reconciled::clear_apply_or_reply() {
  apply_or_reply_ = 0u;
  clear_has_apply_or_reply();
}
inline ::google::protobuf::uint32 Reconciled::apply_or_reply() const {
  return apply_or_reply_;
}
inline void Reconciled::set_apply_or_reply(::google::protobuf::uint32 value) {
  set_has_apply_or_reply();
  apply_or_reply_ = value;
}

// required uint32 src_user_locate = 2;
inline bool Reconciled::has_src_user_locate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Reconciled::set_has_src_user_locate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Reconciled::clear_has_src_user_locate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Reconciled::clear_src_user_locate() {
  src_user_locate_ = 0u;
  clear_has_src_user_locate();
}
inline ::google::protobuf::uint32 Reconciled::src_user_locate() const {
  return src_user_locate_;
}
inline void Reconciled::set_src_user_locate(::google::protobuf::uint32 value) {
  set_has_src_user_locate();
  src_user_locate_ = value;
}

// required uint32 tar_user_locate = 3;
inline bool Reconciled::has_tar_user_locate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Reconciled::set_has_tar_user_locate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Reconciled::clear_has_tar_user_locate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Reconciled::clear_tar_user_locate() {
  tar_user_locate_ = 0u;
  clear_has_tar_user_locate();
}
inline ::google::protobuf::uint32 Reconciled::tar_user_locate() const {
  return tar_user_locate_;
}
inline void Reconciled::set_tar_user_locate(::google::protobuf::uint32 value) {
  set_has_tar_user_locate();
  tar_user_locate_ = value;
}

// optional string status = 4;
inline bool Reconciled::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Reconciled::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Reconciled::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Reconciled::clear_status() {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& Reconciled::status() const {
  return *status_;
}
inline void Reconciled::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void Reconciled::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void Reconciled::set_status(const char* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Reconciled::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  return status_;
}
inline ::std::string* Reconciled::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// GiveUp

// required uint32 src_user_locate = 1;
inline bool GiveUp::has_src_user_locate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GiveUp::set_has_src_user_locate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GiveUp::clear_has_src_user_locate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GiveUp::clear_src_user_locate() {
  src_user_locate_ = 0u;
  clear_has_src_user_locate();
}
inline ::google::protobuf::uint32 GiveUp::src_user_locate() const {
  return src_user_locate_;
}
inline void GiveUp::set_src_user_locate(::google::protobuf::uint32 value) {
  set_has_src_user_locate();
  src_user_locate_ = value;
}

// optional string opt = 2;
inline bool GiveUp::has_opt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GiveUp::set_has_opt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GiveUp::clear_has_opt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GiveUp::clear_opt() {
  if (opt_ != &::google::protobuf::internal::kEmptyString) {
    opt_->clear();
  }
  clear_has_opt();
}
inline const ::std::string& GiveUp::opt() const {
  return *opt_;
}
inline void GiveUp::set_opt(const ::std::string& value) {
  set_has_opt();
  if (opt_ == &::google::protobuf::internal::kEmptyString) {
    opt_ = new ::std::string;
  }
  opt_->assign(value);
}
inline void GiveUp::set_opt(const char* value) {
  set_has_opt();
  if (opt_ == &::google::protobuf::internal::kEmptyString) {
    opt_ = new ::std::string;
  }
  opt_->assign(value);
}
inline void GiveUp::set_opt(const char* value, size_t size) {
  set_has_opt();
  if (opt_ == &::google::protobuf::internal::kEmptyString) {
    opt_ = new ::std::string;
  }
  opt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GiveUp::mutable_opt() {
  set_has_opt();
  if (opt_ == &::google::protobuf::internal::kEmptyString) {
    opt_ = new ::std::string;
  }
  return opt_;
}
inline ::std::string* GiveUp::release_opt() {
  clear_has_opt();
  if (opt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = opt_;
    opt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Undo

// required uint32 rep_or_respon = 1;
inline bool Undo::has_rep_or_respon() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Undo::set_has_rep_or_respon() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Undo::clear_has_rep_or_respon() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Undo::clear_rep_or_respon() {
  rep_or_respon_ = 0u;
  clear_has_rep_or_respon();
}
inline ::google::protobuf::uint32 Undo::rep_or_respon() const {
  return rep_or_respon_;
}
inline void Undo::set_rep_or_respon(::google::protobuf::uint32 value) {
  set_has_rep_or_respon();
  rep_or_respon_ = value;
}

// required uint32 src_user_locate = 2;
inline bool Undo::has_src_user_locate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Undo::set_has_src_user_locate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Undo::clear_has_src_user_locate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Undo::clear_src_user_locate() {
  src_user_locate_ = 0u;
  clear_has_src_user_locate();
}
inline ::google::protobuf::uint32 Undo::src_user_locate() const {
  return src_user_locate_;
}
inline void Undo::set_src_user_locate(::google::protobuf::uint32 value) {
  set_has_src_user_locate();
  src_user_locate_ = value;
}

// required uint32 tar_user_locate = 3;
inline bool Undo::has_tar_user_locate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Undo::set_has_tar_user_locate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Undo::clear_has_tar_user_locate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Undo::clear_tar_user_locate() {
  tar_user_locate_ = 0u;
  clear_has_tar_user_locate();
}
inline ::google::protobuf::uint32 Undo::tar_user_locate() const {
  return tar_user_locate_;
}
inline void Undo::set_tar_user_locate(::google::protobuf::uint32 value) {
  set_has_tar_user_locate();
  tar_user_locate_ = value;
}

// optional bool status = 4;
inline bool Undo::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Undo::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Undo::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Undo::clear_status() {
  status_ = false;
  clear_has_status();
}
inline bool Undo::status() const {
  return status_;
}
inline void Undo::set_status(bool value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// GameReadyReq

// required uint32 src_user_locate = 1;
inline bool GameReadyReq::has_src_user_locate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameReadyReq::set_has_src_user_locate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameReadyReq::clear_has_src_user_locate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameReadyReq::clear_src_user_locate() {
  src_user_locate_ = 0u;
  clear_has_src_user_locate();
}
inline ::google::protobuf::uint32 GameReadyReq::src_user_locate() const {
  return src_user_locate_;
}
inline void GameReadyReq::set_src_user_locate(::google::protobuf::uint32 value) {
  set_has_src_user_locate();
  src_user_locate_ = value;
}

// optional uint32 opcode = 2;
inline bool GameReadyReq::has_opcode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameReadyReq::set_has_opcode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameReadyReq::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameReadyReq::clear_opcode() {
  opcode_ = 0u;
  clear_has_opcode();
}
inline ::google::protobuf::uint32 GameReadyReq::opcode() const {
  return opcode_;
}
inline void GameReadyReq::set_opcode(::google::protobuf::uint32 value) {
  set_has_opcode();
  opcode_ = value;
}

// optional uint32 total_time = 3;
inline bool GameReadyReq::has_total_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameReadyReq::set_has_total_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameReadyReq::clear_has_total_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameReadyReq::clear_total_time() {
  total_time_ = 0u;
  clear_has_total_time();
}
inline ::google::protobuf::uint32 GameReadyReq::total_time() const {
  return total_time_;
}
inline void GameReadyReq::set_total_time(::google::protobuf::uint32 value) {
  set_has_total_time();
  total_time_ = value;
}

// optional uint32 single_step_time = 4;
inline bool GameReadyReq::has_single_step_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameReadyReq::set_has_single_step_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameReadyReq::clear_has_single_step_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameReadyReq::clear_single_step_time() {
  single_step_time_ = 0u;
  clear_has_single_step_time();
}
inline ::google::protobuf::uint32 GameReadyReq::single_step_time() const {
  return single_step_time_;
}
inline void GameReadyReq::set_single_step_time(::google::protobuf::uint32 value) {
  set_has_single_step_time();
  single_step_time_ = value;
}

// -------------------------------------------------------------------

// GameStatusReply

// required bool left_user_status = 1;
inline bool GameStatusReply::has_left_user_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameStatusReply::set_has_left_user_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameStatusReply::clear_has_left_user_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameStatusReply::clear_left_user_status() {
  left_user_status_ = false;
  clear_has_left_user_status();
}
inline bool GameStatusReply::left_user_status() const {
  return left_user_status_;
}
inline void GameStatusReply::set_left_user_status(bool value) {
  set_has_left_user_status();
  left_user_status_ = value;
}

// required bool right_user_status = 2;
inline bool GameStatusReply::has_right_user_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameStatusReply::set_has_right_user_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameStatusReply::clear_has_right_user_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameStatusReply::clear_right_user_status() {
  right_user_status_ = false;
  clear_has_right_user_status();
}
inline bool GameStatusReply::right_user_status() const {
  return right_user_status_;
}
inline void GameStatusReply::set_right_user_status(bool value) {
  set_has_right_user_status();
  right_user_status_ = value;
}

// required bool bottom_user_status = 3;
inline bool GameStatusReply::has_bottom_user_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameStatusReply::set_has_bottom_user_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameStatusReply::clear_has_bottom_user_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameStatusReply::clear_bottom_user_status() {
  bottom_user_status_ = false;
  clear_has_bottom_user_status();
}
inline bool GameStatusReply::bottom_user_status() const {
  return bottom_user_status_;
}
inline void GameStatusReply::set_bottom_user_status(bool value) {
  set_has_bottom_user_status();
  bottom_user_status_ = value;
}

// required uint32 token_locate = 4;
inline bool GameStatusReply::has_token_locate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameStatusReply::set_has_token_locate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameStatusReply::clear_has_token_locate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameStatusReply::clear_token_locate() {
  token_locate_ = 0u;
  clear_has_token_locate();
}
inline ::google::protobuf::uint32 GameStatusReply::token_locate() const {
  return token_locate_;
}
inline void GameStatusReply::set_token_locate(::google::protobuf::uint32 value) {
  set_has_token_locate();
  token_locate_ = value;
}

// required uint32 total_time = 5;
inline bool GameStatusReply::has_total_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameStatusReply::set_has_total_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameStatusReply::clear_has_total_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameStatusReply::clear_total_time() {
  total_time_ = 0u;
  clear_has_total_time();
}
inline ::google::protobuf::uint32 GameStatusReply::total_time() const {
  return total_time_;
}
inline void GameStatusReply::set_total_time(::google::protobuf::uint32 value) {
  set_has_total_time();
  total_time_ = value;
}

// required uint32 single_step_time = 6;
inline bool GameStatusReply::has_single_step_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameStatusReply::set_has_single_step_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameStatusReply::clear_has_single_step_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameStatusReply::clear_single_step_time() {
  single_step_time_ = 0u;
  clear_has_single_step_time();
}
inline ::google::protobuf::uint32 GameStatusReply::single_step_time() const {
  return single_step_time_;
}
inline void GameStatusReply::set_single_step_time(::google::protobuf::uint32 value) {
  set_has_single_step_time();
  single_step_time_ = value;
}

// -------------------------------------------------------------------

// FindPassword

// required string email = 1;
inline bool FindPassword::has_email() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FindPassword::set_has_email() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FindPassword::clear_has_email() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FindPassword::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& FindPassword::email() const {
  return *email_;
}
inline void FindPassword::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void FindPassword::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void FindPassword::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FindPassword::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* FindPassword::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string opt = 2;
inline bool FindPassword::has_opt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FindPassword::set_has_opt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FindPassword::clear_has_opt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FindPassword::clear_opt() {
  if (opt_ != &::google::protobuf::internal::kEmptyString) {
    opt_->clear();
  }
  clear_has_opt();
}
inline const ::std::string& FindPassword::opt() const {
  return *opt_;
}
inline void FindPassword::set_opt(const ::std::string& value) {
  set_has_opt();
  if (opt_ == &::google::protobuf::internal::kEmptyString) {
    opt_ = new ::std::string;
  }
  opt_->assign(value);
}
inline void FindPassword::set_opt(const char* value) {
  set_has_opt();
  if (opt_ == &::google::protobuf::internal::kEmptyString) {
    opt_ = new ::std::string;
  }
  opt_->assign(value);
}
inline void FindPassword::set_opt(const char* value, size_t size) {
  set_has_opt();
  if (opt_ == &::google::protobuf::internal::kEmptyString) {
    opt_ = new ::std::string;
  }
  opt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FindPassword::mutable_opt() {
  set_has_opt();
  if (opt_ == &::google::protobuf::internal::kEmptyString) {
    opt_ = new ::std::string;
  }
  return opt_;
}
inline ::std::string* FindPassword::release_opt() {
  clear_has_opt();
  if (opt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = opt_;
    opt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// UpdateUserInfo

// required string user_name = 1;
inline bool UpdateUserInfo::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateUserInfo::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateUserInfo::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateUserInfo::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& UpdateUserInfo::user_name() const {
  return *user_name_;
}
inline void UpdateUserInfo::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void UpdateUserInfo::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void UpdateUserInfo::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateUserInfo::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* UpdateUserInfo::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string account = 2;
inline bool UpdateUserInfo::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateUserInfo::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateUserInfo::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateUserInfo::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& UpdateUserInfo::account() const {
  return *account_;
}
inline void UpdateUserInfo::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void UpdateUserInfo::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void UpdateUserInfo::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateUserInfo::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* UpdateUserInfo::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string password = 3;
inline bool UpdateUserInfo::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateUserInfo::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateUserInfo::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateUserInfo::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& UpdateUserInfo::password() const {
  return *password_;
}
inline void UpdateUserInfo::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void UpdateUserInfo::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void UpdateUserInfo::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateUserInfo::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* UpdateUserInfo::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string ex_email = 4;
inline bool UpdateUserInfo::has_ex_email() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpdateUserInfo::set_has_ex_email() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpdateUserInfo::clear_has_ex_email() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpdateUserInfo::clear_ex_email() {
  if (ex_email_ != &::google::protobuf::internal::kEmptyString) {
    ex_email_->clear();
  }
  clear_has_ex_email();
}
inline const ::std::string& UpdateUserInfo::ex_email() const {
  return *ex_email_;
}
inline void UpdateUserInfo::set_ex_email(const ::std::string& value) {
  set_has_ex_email();
  if (ex_email_ == &::google::protobuf::internal::kEmptyString) {
    ex_email_ = new ::std::string;
  }
  ex_email_->assign(value);
}
inline void UpdateUserInfo::set_ex_email(const char* value) {
  set_has_ex_email();
  if (ex_email_ == &::google::protobuf::internal::kEmptyString) {
    ex_email_ = new ::std::string;
  }
  ex_email_->assign(value);
}
inline void UpdateUserInfo::set_ex_email(const char* value, size_t size) {
  set_has_ex_email();
  if (ex_email_ == &::google::protobuf::internal::kEmptyString) {
    ex_email_ = new ::std::string;
  }
  ex_email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateUserInfo::mutable_ex_email() {
  set_has_ex_email();
  if (ex_email_ == &::google::protobuf::internal::kEmptyString) {
    ex_email_ = new ::std::string;
  }
  return ex_email_;
}
inline ::std::string* UpdateUserInfo::release_ex_email() {
  clear_has_ex_email();
  if (ex_email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ex_email_;
    ex_email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string phone = 5;
inline bool UpdateUserInfo::has_phone() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UpdateUserInfo::set_has_phone() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UpdateUserInfo::clear_has_phone() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UpdateUserInfo::clear_phone() {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& UpdateUserInfo::phone() const {
  return *phone_;
}
inline void UpdateUserInfo::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void UpdateUserInfo::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void UpdateUserInfo::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateUserInfo::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  return phone_;
}
inline ::std::string* UpdateUserInfo::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes head_image = 6;
inline bool UpdateUserInfo::has_head_image() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UpdateUserInfo::set_has_head_image() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UpdateUserInfo::clear_has_head_image() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UpdateUserInfo::clear_head_image() {
  if (head_image_ != &::google::protobuf::internal::kEmptyString) {
    head_image_->clear();
  }
  clear_has_head_image();
}
inline const ::std::string& UpdateUserInfo::head_image() const {
  return *head_image_;
}
inline void UpdateUserInfo::set_head_image(const ::std::string& value) {
  set_has_head_image();
  if (head_image_ == &::google::protobuf::internal::kEmptyString) {
    head_image_ = new ::std::string;
  }
  head_image_->assign(value);
}
inline void UpdateUserInfo::set_head_image(const char* value) {
  set_has_head_image();
  if (head_image_ == &::google::protobuf::internal::kEmptyString) {
    head_image_ = new ::std::string;
  }
  head_image_->assign(value);
}
inline void UpdateUserInfo::set_head_image(const void* value, size_t size) {
  set_has_head_image();
  if (head_image_ == &::google::protobuf::internal::kEmptyString) {
    head_image_ = new ::std::string;
  }
  head_image_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UpdateUserInfo::mutable_head_image() {
  set_has_head_image();
  if (head_image_ == &::google::protobuf::internal::kEmptyString) {
    head_image_ = new ::std::string;
  }
  return head_image_;
}
inline ::std::string* UpdateUserInfo::release_head_image() {
  clear_has_head_image();
  if (head_image_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = head_image_;
    head_image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// AdPictureItem

// required uint32 image_type = 1;
inline bool AdPictureItem::has_image_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdPictureItem::set_has_image_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdPictureItem::clear_has_image_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdPictureItem::clear_image_type() {
  image_type_ = 0u;
  clear_has_image_type();
}
inline ::google::protobuf::uint32 AdPictureItem::image_type() const {
  return image_type_;
}
inline void AdPictureItem::set_image_type(::google::protobuf::uint32 value) {
  set_has_image_type();
  image_type_ = value;
}

// required string image_name = 2;
inline bool AdPictureItem::has_image_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdPictureItem::set_has_image_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdPictureItem::clear_has_image_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdPictureItem::clear_image_name() {
  if (image_name_ != &::google::protobuf::internal::kEmptyString) {
    image_name_->clear();
  }
  clear_has_image_name();
}
inline const ::std::string& AdPictureItem::image_name() const {
  return *image_name_;
}
inline void AdPictureItem::set_image_name(const ::std::string& value) {
  set_has_image_name();
  if (image_name_ == &::google::protobuf::internal::kEmptyString) {
    image_name_ = new ::std::string;
  }
  image_name_->assign(value);
}
inline void AdPictureItem::set_image_name(const char* value) {
  set_has_image_name();
  if (image_name_ == &::google::protobuf::internal::kEmptyString) {
    image_name_ = new ::std::string;
  }
  image_name_->assign(value);
}
inline void AdPictureItem::set_image_name(const char* value, size_t size) {
  set_has_image_name();
  if (image_name_ == &::google::protobuf::internal::kEmptyString) {
    image_name_ = new ::std::string;
  }
  image_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AdPictureItem::mutable_image_name() {
  set_has_image_name();
  if (image_name_ == &::google::protobuf::internal::kEmptyString) {
    image_name_ = new ::std::string;
  }
  return image_name_;
}
inline ::std::string* AdPictureItem::release_image_name() {
  clear_has_image_name();
  if (image_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = image_name_;
    image_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required bool existed = 3;
inline bool AdPictureItem::has_existed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AdPictureItem::set_has_existed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AdPictureItem::clear_has_existed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AdPictureItem::clear_existed() {
  existed_ = false;
  clear_has_existed();
}
inline bool AdPictureItem::existed() const {
  return existed_;
}
inline void AdPictureItem::set_existed(bool value) {
  set_has_existed();
  existed_ = value;
}

// optional string image_hashcode = 4;
inline bool AdPictureItem::has_image_hashcode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AdPictureItem::set_has_image_hashcode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AdPictureItem::clear_has_image_hashcode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AdPictureItem::clear_image_hashcode() {
  if (image_hashcode_ != &::google::protobuf::internal::kEmptyString) {
    image_hashcode_->clear();
  }
  clear_has_image_hashcode();
}
inline const ::std::string& AdPictureItem::image_hashcode() const {
  return *image_hashcode_;
}
inline void AdPictureItem::set_image_hashcode(const ::std::string& value) {
  set_has_image_hashcode();
  if (image_hashcode_ == &::google::protobuf::internal::kEmptyString) {
    image_hashcode_ = new ::std::string;
  }
  image_hashcode_->assign(value);
}
inline void AdPictureItem::set_image_hashcode(const char* value) {
  set_has_image_hashcode();
  if (image_hashcode_ == &::google::protobuf::internal::kEmptyString) {
    image_hashcode_ = new ::std::string;
  }
  image_hashcode_->assign(value);
}
inline void AdPictureItem::set_image_hashcode(const char* value, size_t size) {
  set_has_image_hashcode();
  if (image_hashcode_ == &::google::protobuf::internal::kEmptyString) {
    image_hashcode_ = new ::std::string;
  }
  image_hashcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AdPictureItem::mutable_image_hashcode() {
  set_has_image_hashcode();
  if (image_hashcode_ == &::google::protobuf::internal::kEmptyString) {
    image_hashcode_ = new ::std::string;
  }
  return image_hashcode_;
}
inline ::std::string* AdPictureItem::release_image_hashcode() {
  clear_has_image_hashcode();
  if (image_hashcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = image_hashcode_;
    image_hashcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string url = 5;
inline bool AdPictureItem::has_url() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AdPictureItem::set_has_url() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AdPictureItem::clear_has_url() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AdPictureItem::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& AdPictureItem::url() const {
  return *url_;
}
inline void AdPictureItem::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void AdPictureItem::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void AdPictureItem::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AdPictureItem::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* AdPictureItem::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional uint32 image_size = 6;
inline bool AdPictureItem::has_image_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AdPictureItem::set_has_image_size() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AdPictureItem::clear_has_image_size() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AdPictureItem::clear_image_size() {
  image_size_ = 0u;
  clear_has_image_size();
}
inline ::google::protobuf::uint32 AdPictureItem::image_size() const {
  return image_size_;
}
inline void AdPictureItem::set_image_size(::google::protobuf::uint32 value) {
  set_has_image_size();
  image_size_ = value;
}

// required uint32 image_id = 7;
inline bool AdPictureItem::has_image_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AdPictureItem::set_has_image_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AdPictureItem::clear_has_image_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AdPictureItem::clear_image_id() {
  image_id_ = 0u;
  clear_has_image_id();
}
inline ::google::protobuf::uint32 AdPictureItem::image_id() const {
  return image_id_;
}
inline void AdPictureItem::set_image_id(::google::protobuf::uint32 value) {
  set_has_image_id();
  image_id_ = value;
}

// optional bool last_one = 8;
inline bool AdPictureItem::has_last_one() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AdPictureItem::set_has_last_one() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AdPictureItem::clear_has_last_one() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AdPictureItem::clear_last_one() {
  last_one_ = false;
  clear_has_last_one();
}
inline bool AdPictureItem::last_one() const {
  return last_one_;
}
inline void AdPictureItem::set_last_one(bool value) {
  set_has_last_one();
  last_one_ = value;
}

// -------------------------------------------------------------------

// AdPictureReply

// required bool synced = 1;
inline bool AdPictureReply::has_synced() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdPictureReply::set_has_synced() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdPictureReply::clear_has_synced() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdPictureReply::clear_synced() {
  synced_ = false;
  clear_has_synced();
}
inline bool AdPictureReply::synced() const {
  return synced_;
}
inline void AdPictureReply::set_synced(bool value) {
  set_has_synced();
  synced_ = value;
}

// optional bytes content = 2;
inline bool AdPictureReply::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdPictureReply::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdPictureReply::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdPictureReply::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& AdPictureReply::content() const {
  return *content_;
}
inline void AdPictureReply::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void AdPictureReply::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void AdPictureReply::set_content(const void* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AdPictureReply::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* AdPictureReply::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool ended = 3;
inline bool AdPictureReply::has_ended() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AdPictureReply::set_has_ended() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AdPictureReply::clear_has_ended() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AdPictureReply::clear_ended() {
  ended_ = false;
  clear_has_ended();
}
inline bool AdPictureReply::ended() const {
  return ended_;
}
inline void AdPictureReply::set_ended(bool value) {
  set_has_ended();
  ended_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace MessageStruct

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_message_2eproto__INCLUDED
